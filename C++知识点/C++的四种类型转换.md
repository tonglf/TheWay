# C++的四种类型转换

C 语言的转换方式很简单，可以在任意类型之间转换，但这也恰恰是它的缺点，因为极不安全。可能不经意间将指向const 对象的指针转换成非const 对象的指针，可能将基类对象指针转成了派生类对象的指针，这种转换很容易出bug，需要严格审查代码才能消除这种隐患，但是C 这种转换方式不利于我们审查代码，且程序运行时也可能会出bug。

C++引入的这几种类型转换可以完美的解决上述问题，不同场景下不同需求使用不同的类型转换方式，同时有利于代码审查。

## static_cast

使用场景：

> 1. 基本数据类型之间的转换使用，例如 float 转 int，int 转 char等，在有类型指针和 void* 之间转换使用（ new 中 使用 malloc 分配内存后的得到的 void* 转为实际的类型），子类对象指针转换为父类对象指针也可以使用 static_cast。
> 2. 非多态类型转换一般都使用 static_cast，而且最好把所有的隐式类型转换都用 static_cast 进行显示类型替换，不能使用  static_cast 在有类型指针之间进行类型转换。

## dynamic_cast

使用场景：

> 用于将父类的指针或引用转换为子类的指针或引用，此场景下父类必须要有虚函数，因为dynamic_cast 是运行时检查，
> 检查需要运行时信息RTTI，而RTTI 存储在虚函数表中。

## const_cast

使用场景：

> 用于常量指针或引用与非常量指针或引用之间的转换，只有const_cast 才可以对常量进行操作，一般都是用它来去除常量
> 性，去除常量性是危险操作，还是要谨慎操作。

## reinterpret_cast

使用场景：

> 没啥场景，类似C 语言中的强制类型转换，什么都可以转，万不得已不要使用，一般前三种转换方式不能解决问题了使用
> 这种强制类型转换方式。