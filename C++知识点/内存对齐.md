# 内存对齐

**内存对齐的原因：**

- 平台的移植性好，并不是所有的硬件平台都能存放任意地址的数据，某些平台只能在某些地址访问特定类型的数据，否则就会出现异常
- cpu 处理效率高：cpu 并不是把内存看成以字节为单位，而是以块为单位，cpu 在读取内存的时候是一块一块的读取的

内存对齐原则：

- 找内部类型最大的存储字节，**最后的存储大小必定是最大存储字节的倍数**
- 常见类型占用字节大小：`char` : 1   ` int` : 4    `float` : 4    `double` : 8

**例子：**

​		以下代码注释中表示变量在内存中占用内存的位置，默认从 0 开始

```cpp
#include <iostream>

struct A {
    char i;		// 0 
    int a;		// 4 - 7
};				// size : 8 (int4 倍数)

struct B {
    char c1;	// 0 
    char c2;	// 1
    int a;		// 4 - 7
};				// size : 8 (int4 倍数)

struct C {
    char c1;	// 0 
    char c2;	// 1
    int a;		// 4 - 7
    double d;	// 8 - 15
};				// size : 16 (double8 倍数)

struct D {
    char c1;	// 0 
    char c2;	// 1
    double d;	// 8 - 15
    int a;		// 16 - 19
};				// size : 20 + 4 = 24 (double8 倍数)

struct E {
    double d;	// 0 - 7
    int a;		// 8 - 11
    int b;		// 12 - 15
    char c;		// 16
};				// size : 17 + 7 = 24 (double8 倍数)

struct F {
    double d;	// 0 - 7
    int a;		// 8 - 11
    char c;		// 12
};				// size : 13 + 3 = 16 (double8 倍数)

struct G {
    double d;	// 0 - 7
    char c;		// 8
    int a;		// 12 - 15
};				// size : 16 (double8 倍数)

struct H {
	double d;	// 0 - 7
	char c;		// 8
	int a;		// 12 - 15
	float f;	// 16 - 23
	int i;		// 24 - 27
};				// size : 28 + 4 = 32 (double8 倍数)

int main()
{
    std::cout << sizeof(A) << std::endl;
	std::cout << sizeof(B) << std::endl;
	std::cout << sizeof(C) << std::endl;
	std::cout << sizeof(D) << std::endl;
	std::cout << sizeof(E) << std::endl;
	std::cout << sizeof(F) << std::endl;
	std::cout << sizeof(G) << std::endl;
	std::cout << sizeof(H) << std::endl;
}
```

