@[TOC](目录)

## 7、模板与泛型编程 <br> &emsp;&emsp;Templates and Generic Programming
### &emsp;条款41：了解隐式接口和编译期多态
- classes 和 templates 都支持接口（ interface ）和多态（ polymorphism ）。
- 对 classes 而言接口是显示的（ explicit ），以函数签名为中心。多态则是通过 virtual 函数发生于运行期。
- 对 template 参数而言，接口是隐式的（ implicit ），奠基于有效表达式。多态则是通过 template 具现化和函数重载解析（ function overloading resolution ）发生于编译期。
### &emsp;条款42：了解 typename 的双重意义
 - 声明 template 参数时，前缀关键字 class 和 typename 可互换。
 - 请使用关键字 typename 标识嵌套从属类型名称；但不得在 base class lists（基类列）或 member initialization list（成员初始列）内以它作为 base class 修饰符。
### &emsp;条款43：学习处理模板化基类内的名称
 - 可在 derived class templates 内通过 “this- >” 指涉 base class templates 内的成员名称，或藉由一个明白写出的 “ base class 资格修饰符” 完成。
### &emsp;条款44：将与参数无关的代码抽离 templates
- Templates 生成多个 classes 和多个函数，所以任何 template 代码都不应该与某个造成膨胀的 template 参数产生相依关系。
- 因非类型模板参数（ non-type template parameters ）而造成的代码膨胀，往往可消除，做法是以函数参数或 class 成员变量替换 template 参数。
- 因类型参数（ type parameters ）而造成的代码膨胀，往往可降低，做法是让带有完全相同二进制表述（ binary representations ）的具现类型（ instantiation types ）共享实现码。

### &emsp;条款45：运用成员函数模板接受所有兼容类型

### &emsp;条款46：需要类型转换时请为模板定义非成员函数

### &emsp;条款47：请使用 traits classes 表现类型信息

### &emsp;条款48：认识 template 元编程
