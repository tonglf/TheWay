@[TOC](目录)

## 4、设计与声明 <br> &emsp;&emsp;Designs and Declarations
### &emsp;条款18：让接口容易被正确使用，不易被误用

 - 好的接口很容易被正确使用，不容易被误用。你应该在你所有的接口中努力达成这些性质。
 - “促使正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。
 - “阻止误用”的办法包括建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。
 - trl::shared_ptr 支持定制型删除器（ custom deleter ）。这可防范 DLL 问题，可被用来自动解除互斥锁 （ mutexes ）等等。

### &emsp;条款19：设计 class 犹如设计 type

 - Class 的设计就是 type 的设计。在定义一个新 type 之前，请确定你已经考虑过本条款覆盖的所有讨论主题。

### &emsp;条款20：宁以 pass-by-reference-to-const 替换 pass-by-value

 - 尽量以 pass-by-reference-to-const 替换 pass-by-value 。前者通常比较高效，并可避免切割问题 （ slicing problem ）。
 - 以上规则并不适用于内置类型，以及 STL 的迭代器和函数对象。对他们而言， pass-by-value 往往比较适当。

### &emsp;条款21：必须返回对象时，别妄想返回其 reference

 - 绝不要返回 pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象。条款 4 已经为“在单线程环境中合理返回 reference 指向一个 local static 对象”提供了一份设计实例。

### &emsp;条款22：将成员变量声明为 private
 - 切记将成员变量声明为 private 。这可赋予客户访问数据的一致性、可细微划分访问控制、允许约束条件获得保证，并提供 class 作者以充分的实现弹性。
 - protected 并不比 public 更具封装性。
### &emsp;条款23：宁以 non-member、non-friend 替换 member 函数
 - 宁可拿 non-member non-friend 函数替换 member 函数。这样做可以增加封装性、包括弹性（ packaging flexiblity ）和机能扩充性。
### &emsp;条款24：若所有参数皆需类型转换，请为此采用 non-member 函数
 - 如果你需要为某个函数的所有参数（包括 this 指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是non-member 。
### &emsp;条款25：考虑写出一个不抛异常的 swap 函数
 - 当 std::swap 对你的类型效率不高时，提供一个 swap 成员函数，并确定这个函数不抛出异常。
 - 如果你提供一个 member swap ，也提供一个 non-member swap 用来调用前者。对于 classes （而非 templates ），也请特化 std::swap 。
 - 调用 swap 时指针对 std::swap 使用 using 声明式，然后调用 swap 并且不带任何“命名空间资格修饰”。
 - 为“用户定义类型”进行 std templates 全特化是好的，但千万不要尝试在 std 内加入某些对 std 而言全新的东西。
