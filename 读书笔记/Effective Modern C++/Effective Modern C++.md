# Effective Modern C++

# 第一章 型别推导



# 第二章 auto



# 第三章 转向现代 C++

## 7、在创建对象时注意区分 () 和 {}

**要点速记：**

- 大括号初始化可以应用的语境最为宽泛，可以阻止隐式窄化型别转换，还对最令人苦恼之解析语法免疫。
- 在构造函数重载决议期间，只要有任何可能，大括号初始化物就会与带有 `std::initializer_list` 型别的形参相匹配，即使其他重载版本有着貌似更加匹配的形参表。
- 使用小括号还是大括号，会造成结果大相径庭的一个例子是：使用两个实参来创建一个 `std::vector<数值类型>` 对象。
- 在模板内容进行对象创建时，到底该使用小括号还是大括号会成为一个棘手的问题。



## 8、优先选用 nullptr，而非 0 或 NULL

**要点速记：**

- 相对于 0 和 NULL，优先使用 nullptr。
- 避免在整型和指针型别之间重载。



## 9、优先选用别名声明，而非 typedef

- `typedef` 不支持模板化，但别名声明支持。
- 别名模板可以让人免写 “ `::type` “ 后缀，并且在模板内，对于内嵌 `typedef` 的引用经常要求加上 `typename` 前缀。



## 10、优先选用限定作用域的枚举类型别，而非不限作用域的枚举型别

**要点速记：**

- C++ 98 风格的枚举型别，现在称为不限范围的枚举型别。
- 限定作用域的枚举型别仅在枚举型别内可见。它们只能通过强制型别转换以转换至其他型别。
- 限定作用域的枚举型别和不限范围的枚举型别都支持底层型别指定。限定作用域的枚举型别默认底层型别是 `int`，而不限范围的枚举型别没有默认底层型别。
- 限定作用域的枚举型别总是可以进行前置声明，而不限范围的枚举类型却只有在指定了默认底层型别的前提下才可以进行前置声明。



## 11、优先选用删除函数，而非 private 未定义函数

**要点速记：**

- 优先选用删除函数（`= delete`），而非 private 未定义函数。
- 任何函数都可以删除，包括非成员函数和模板具现。



## 12、为意在改写的函数添加 override 声明

**要点速记：**

- 为意在改写的函数添加 override 声明。
- 成员函数引用饰词使得对于左值和右值对象（ *this ）的处理能够区分开来。



## 13、优先选用 const_iterator，而非 iterator

**要点速记：**

- 优先选用 const_iterator，而非 iterator。
- 在最通用的代码中，优先选用非成员函数版本的 begin、end 和 rbegin等，而非其成员版本函数。



## 14、只要函数不会发射异常，就为其加上 noexcept 声明

**要点速记：**

- noexcept 声明是函数接口的组成部分，这意味着调用方可能会对它有依赖。

- 相对于不带 noexcept 声明的函数，带有 noexcept 声明的函数有更多机会得到优化。
- noexcept 性质对于移动操作、swap、内存释放函数和析构函数最有价值。
- 大多数函数都是异常中立的，不具备 noexcept 性质。



## 15、只要有可能使用 constexpr，就使用它

**要点速记：**

- constexpr 对象都具备 const 属性，并由编译期已知的值完成初始化。
- constexpr 函数在调用时若传入的实参值是编译器已知的，则会产出编译期结果。
- 比起非 constexpr 对象或 constexpr 函数而言，constexpr 对象或是 constexpr 函数可以在一个作用域更广的语境中。



## 16、保证 const 成员函数的线程安全性

**要点速记：**

- 保证 const 成员函数的线程安全性，除非可以确信它们不会用在并在语境中。
- 运用 std::atomic 型别的变量会比运用互斥量提供更好的性能，但前者仅适用对单个变量或内存区域的操作。



## 17、理解特种成员函数的生成机制

**要点速记：**

- 特种成员函数是指那些 C++　会自动生成的成员函数：默认构造函数、析构函数、复制函数（拷贝构造函数、赋值运算符），以及移动操作（移动构造函数、移动运算符 —— C++ 新加入的两个函数）。
- 移动操作仅当类中未包含用户显式声明的复制操作、移动操作和析构函数是才生成。
- 复制构造函数仅当类中不包含用户显式声明的复制构造函数时才生成，如果该类声明了移动操作则复制构造函数将被删除，复制赋值运算符仅当类中不包含用户显式声明的复制赋值运算符才生成，如果该类声明了移动操作则复制赋值运算符将被删除。在已经存在显式声明的析构函数的条件下，生成复制操作已经成为了被废弃的行为。
- 成员函数模板在任何情况下都不会抑制特种成员函数的生成。



# 第四章 智能指针



# 第五章 右值引用、移动语义和完美转发



# 第六章 lambda 表达式



# 第七章 并发 API



# 第八章 微调
