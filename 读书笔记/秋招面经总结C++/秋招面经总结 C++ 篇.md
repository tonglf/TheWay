# 2021 秋招面经总结 —— C++ 篇（一）

> 作者：leetcode-Crystal

当然只看总结好的面经并不一定能够完全理解其中的知识点，建议看到不懂的地方查阅下《C++Primer》这本书。这本书内容十分全面，但是也比较厚，可以作为一本工具书来看，如果从头到尾看下来可能比较耗时间，推荐的做法是抽取其中的一部分知识点来看，边看边总结。笔者当时是从头到尾看了一遍，极为不推荐这种方式，因为重难点内容往往静不下心来看。

## C++ 程序的编译过程（源码如何转化成二进制）

参考链接： 🔗 https://blog.csdn.net/u012662731/article/details/78520349

编译过程分为四个过程：**预处理**、**编译**，**汇编**，**链接**

- 编译预处理：处理以 # 开头的指令
- 编译、优化：将源码 .cpp 文件翻译成 .s 汇编代码
- 汇编：将汇编代码 .s 翻译成机器指令 .o 文件
- 链接：汇编程序生成的目标文件并不会立即执行，可能有源文件中的函数引用了另一个源文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些目标文件连接成一个整体，从而生成可执行的二进制文件。

![1.编译过程](.\Image\1.编译过程.png)

链接分为两种：（静态库、动态库）

参考链接： 🔗 https://www.cnblogs.com/cyyljw/p/10949660.html

·静态链接：代码从其所在的动态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中

·动态链接：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间

二者的优缺点：

·静态链接：浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容

·动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要进行链接，性能会有一定的损失。

## 指针和引用的区别

·指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变。（是否可变）

·指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不占内存空间（是否占内存）

·指针可以为空，但是引用必须绑定对象（是否可为空）

·指针可以有多级，但是引用只能一级（是否能为多级）

## 堆和栈的区别

·申请方式：栈是系统自动分配，堆是程序员主动申请

·申请后系统响应：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上

·栈在内存中是连续的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是不连续的

·申请效率：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片

·存放的内容：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制

## new和delete是如何实现的，new与malloc的异同处

在使用的时候new，delete搭配使用，malloc和free搭配使用。·

·属性：malloc/free 是库函数，需要头文件的支持；new/delete 是关键字，需要编译器的支持

·参数：new 申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；malloc 在申请空间时，需要确定所申请空间的大小

·返回值：new 申请空间时，返回的类型是对象的指针类型，无需强制类型转换，符合类型安全的操作符；malloc 申请空间时，返回的是 void* 类型，需要进行强制类型的转换，转换为对象类型的指针

·分配失败：new 分配失败时，会抛出bad_alloc异常，malloc分配失败时返回空指针

·重载：new/delete 支持重载，malloc/free 不能进行重载

·自定义类型实现：new首先调用operator new 函数申请空间（底层通过 malloc 实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；delete 首先调用析构函数，然后调用 operator delete 释放空间（底层通过 free 实现）。malloc/free 无法进行自定义类型的对象的构造和析构

·内存区域：new 操作符从自由存储区上为对象动态分配内存，而 malloc 函数从堆上动态分配内存。（自由存储区不等于堆）

## C 和 C++ 的区别

·C 是面向过程的编程，特点是函数；

·C++ 是面向对象的编程，特点是类。（特性）

·C 主要用在嵌入式开发、驱动开发和硬件直接打交道的领域；C++ 可以用于应用层的开发、用户界面开发等和操作系统直接打交道的领域。（应用领域）

·C++ 继承了C的底层操作特性，增加了面向对象的机制，增加了泛型编程、异常处理、运算符重载，还增加了命名空间，避免了命名冲突。（相较于 C 的升级）

## C++、Java 的联系与区别，包括语言特性、垃圾回收、应用场景等（java 的垃圾回收机制）

**二者在语言特性上有很大的区别：**

·指针：C++ 可以直接操作指针，容易产生内存泄漏以及非法指针引用的问题；JAVA 并不是没有指针，虚拟机(JVM)内部还是使用了指针，只是编程人员不能直接使用指针，不能通过指针来直接访问内存，并且 JAVA 增加了内存管理机制

·多重继承：C++ 支持多重继承，允许多个父类派生一个类，虽然功能很强大，但是如果使用的不当会造成很多问题，例如：菱形继承；JAVA 不支持多重继承，但允许一个类可以继承多个接口，可以实现 C++ 多重继承的功能，但又避免了多重继承带来的许多不便

·数据类型和类：C++ 可以将变量或函数定义成全局，但是JAVA是完全面向对象的语言，除了基本的数据类型之外，其他的都作为类的对象，包括数组。

**垃圾回收：**

·JAVA 语言一个显著的特点就是垃圾回收机制，编程人员无需考虑内存管理的问题，可以有效的防止内存泄漏，有效的使用空闲的内存

·JAVA 所有的对象都是用 new 操作符建立在内存堆栈上，类似于 C++ 中的 new 操作符，但是当要释放该申请的内存空间时，JAVA 自动进行内存回收操作，C++ 需要程序员自己释放内存空间，并且 JAVA 中的内存回收是以线程的方式在后台运行的，利用空闲时间。

**应用场景：**

·java 运行在虚拟机上，和开发平台无关，C++ 直接编译成可执行文件，是否跨平台在于用到的编译器的特性是否有多平台的支持，

·C++ 可以直接编译成可执行文件，运行效率比 JAVA 高

·JAVA 主要用来开发 web 应用

·C++ 主要用在嵌入式开发、网络、并发编程的方面

## Struct 和 class 的区别

参考链接：https://blog.csdn.net/bestconvenient/article/details/30734139

struct 和 class 都可以自定义数据类型，也支持继承操作

·struct 中默认的访问级别是 public，默认的继承级别也是 public

·class 中默认的访问级别是 private，默认的继承级别也是 private

·当 class 继承 struct 或者 struct 继承 class 时，默认的继承级别取决于默认的继承级别取决于class或struct本身， class(private 继承) ，struct(public 继承)

struct A{}；

class B : A{};   //private继承

struct C : B{}； //public继承

·class 可以使用模板，struct 不能

## define 和 const 的区别（编译阶段、安全性、内存占用等）

·编译阶段：define 是在编译预处理阶段起作用，const 是在编译阶段和程序运行阶段起作用

·安全性：define 定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；const 定义的只读变量是有类型的，是要进行判断的，可以避免一些低级的错误

·内存占用：define 定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份；const 定义的只读变量在程序运行过程中只有一份

·调试：define 定义的不能调试，因为在预编译阶段就已经进行替换了；const 定义的可以进行调试

**const** **的优点：**

·有数据类型，在定义式可进行安全性检查

·可调式

·占用较少的空间

## 在 C++ 中 const 和 static 的用法（定义，用途）

const 参考 🔗 https://blog.csdn.net/Eric_Jo/article/details/4138548?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param

·const 修饰成员变量，定义成 const 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率

·const 修饰函数参数，使得传递过来的函数参数的值不能改变

· const 修饰成员函数，使得成员函数不能修改任何类型的成员变量（mutable 修饰的变量除外，函数参数也除外），也不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量

**static** **定义静态变量，静态函数**

·static 作用于局部变量，改变了局部变量的生存周期，使得该变量存在于定义后直到程序运行结束的这段时间

·static 作用于全局变量和函数，改变了全局变量的作用域，使得全局变量只能在定义它的文件中使用，在源文件中不具有全局可见性

·static 作用于类的成员变量和类的成员函数，使得类变量或者类成员函数和类有关，也就是说可以不定义类的对象就可以通过类访问这些静态成员。注意：类的静态成员函数中只能访问静态成员变量或者静态成员函数，不能将静态成员函数定义成虚函数

## const 和 static 在类中使用的注意事项（定义、初始化和使用）

 

参考 🔗 https://www.runoob.com/w3cnote/cpp-static-const.html

**static** **静态成员变量：**

1、静态成员变量是在类内进行声明，在类外进行定义和初始化，在类外进行定义和初始化的时候不要出现 static 关键字和 private/public/protected 访问规则。

2、静态成员变量相当于类域中的全局变量，被类的所有对象所共享，包括派生类的对象。

3、静态成员变量可以作为成员函数的参数可选参数，而普通成员变量不可以

class base{ 

public : 

  static int _staticVar; 

  int _var; 

  void foo1(int i=_staticVar);    //正确,_staticVar为静态数据成员 

  void foo2(int i=_var);        //错误,_var为普通数据成员 

};

4、静态数据成员的类型可以是所属类的类型，而普通数据成员不可以，普通数据成员只可能声明成类的指针或引用

class base{ 

public : 

  static base _object1;    //正确，静态数据成员 

  base _object2;         //错误 

  base *pObject;         //正确，指针 

  base &mObject;       //正确，引用 

};

**static** **静态成员函数：**

1、静态成员函数不能调用非静态成员变量或者非静态成员函数，因为静态成员函数没有 this 指针。静态成员函数做为类作用域的全局函数

2、静态成员函数不能声明成虚函数（virtual）、const、volatile

**const** **成员变量：**

1、const 成员变量只能在类内声明、定义，在构造函数初始化列表中初始化

2、const 成员变量只在某个对象的生存周期内是常量，对于整个类而言却是可变的，因为类可以创建多个对象，不同类的 const 成员变量的值是不同的，所以不能在类的声明中初始化 const 成员变量，因为类的对象还没有创建，编译器不知道它的值

**const** **成员函数：**

1、不能修改成员变量的值，除非有 mutable 修饰；只能访问成员变量

2、不能调用非常量成员函数，以防修改成员变量的值

**const static****：**

1、如果要想成员变量在整个类中都是恒定的常量，应该用类的枚举常量或者 static const.

2、在类中进行声明，在类外进行初始化（类似于类的静态常量）

## C++ 中的 const 类成员函数（用法和意义）

用法：如上

意义：防止修改成员变量

 

**本篇重点总结：**

·编译过程

·new delete , free malloc 区别和联系

·C++ 和 C 的区别

·C++ 和 Java 的区别

·struct class 区别

·define const 区别

·const static 用法和作用

 

# 2021 秋招面经总结 —— C++ 篇（二）

本篇是即 上一篇面经 之后的第二篇面经，涉及 C++ 在面试过程中常问道的知识点，也是笔者在面试过程中曾经被问到的题目，但是由于公司的不同，面试官的不同，问道的问题的深度也不一样，建议在复习基础知识的时候，首先拓展自己的宽度，当宽度足够了再加深自己的深度。举个非常简单的例子：面试官可能会问道多态是怎么实现的，开始复习的时候可能仅能回答上来“多态是通过虚函数来实现的”；那么更为理想的答案是在回答的过程中我们也简单把“虚函数的底层实现方式”简单描述下，这就体现出我们回答的问题是有深度的。

## （11）计算下面几个类的大小：

参考链接：🔗 https://blog.csdn.net/fengxinlinux/article/details/72836199

类本身没有大小，这里类的大小是指：类对象所占的大小。

·类的大小遵循结构体的对齐规则

·类的大小与普通成员函数和静态成员无关（包括：普通成员函数、静态成员函数、静态数据成员、静态常量数据成员），与普通数据成员有关

·虚函数对类的大小有影响，是因为虚函数指针的影响

·虚继承对类的大小有影响，是因为虚基表指针带来的影响

·空类的大小是 1

例子：

| class A{    //静态成员    static int a;    const static int b;      static int fun1(){}       //普通成员函数    void fun(){}  }; | //普通数据成员  class B{    int a;      };                   |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| //虚函数  class C{    virtual int fun(){}  };                | //结构体对齐原则  class D{    int a;    virtual int fun(){}  }; |

 

int main(){

  cout << sizeof(A) << endl;//1

  cout << sizeof(B) << endl;//4:表示一个整型变量的大小

  cout << sizeof(C) << endl;//8：虚函数表的指针的大小

  cout << sizeof(D) << endl;//16：整型变量的大小+虚函数指针的大小+对齐原则（4）

  return 0;

}

## （12）给一个代码，求输出结果

class A {

public:

​    A(int x){ }

};

问：A a = 1;是否正确, 如果正确, 那么它调用了哪些函数？

正确，这里会进行隐式转化 A a(1).implicit

 

这类题目更常见的是在基类和子类有不同实现方法。（虚函数相关，例子很多，不多说了）

## （13）C++的STL介绍

（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等，笔者也整理过STL相关的面经，有兴趣的可以自行查阅

## （14）STL 源码中的 hash 表的实现

hashtable 是采用开链法来完成的，（vector + list）

·底层键值序列采用vector实现，vector的大小取的是质数，且相邻质数的大小约为2倍关系，当创建 hashtable 时，会自动选取一个接近所创建大小的质数作为当前 hashtable 的大小；

·对应键的值序列采用单向 list 实现；

·当 hashtable 的键 vector 的大小重新分配的时候，原键的值 list 也会重新分配，因为 vector 重建了相当于键增加了，那么原来的值对应的键可能就不同于原来分配的键，这样就需要重新确定值的键。

## （15）STL 中 unordered_map 和 map 的区别

·底层实现不同：

unordered_map 底层实现是一个**哈希表**，元素**无序**

map 底层实现是**红黑树**，其内部所有的元素都是**有序**的，因此对 map 的所有操作，其实都是对红黑树的操作

·优缺点：

unordered_map：查找效率高；但是建立哈希表比较耗费时间

map：内部元素有序，查找和删除操作都是 logn 的时间复杂度；但是维护红黑树的存储结构需要占用一定的内存空间

·适用情况：

对于要求内部元素有序的使用map，对于要求查找效率的用unordered_map

## （16）STL 中 vector 的实现

·vector 是一个动态数组，底层实现是一段连续的线性内存空间。

·扩容的本质：当vector实际所占用的内存空间和容量相等时，如果再往其中添加元素需要进行扩容。其步骤如下：

首先，申请一块更大的存储空间，一般是增加当前容量的50%或者100%，和编译器有关；

然后，将旧内存空间的内容，按照原来的顺序放到新的空间中

最后，将旧内存空间的内容释放掉，本质上其存储空间不会释放，只是删除了里面的内容。

·从 vector 扩容的原理也可以看出：vector容器释放后，与其相关的指针、引用以及迭代器会失效的原因。

## （17）vector 使用的注意点及其原因，频繁对 vector 调用 push_back() 对性能的影响和原因

主要是在插入元素方面：插入元素需要考虑元素的移动问题和是否需要扩容的问题

频繁的调用 push_back() 也是扩容的问题对性能的影响

## （18）C++ 中的重载和重写(覆盖)的区别：

·对于类中函数的重载或者重写而言，重载发生在同一个类的内部，重写发生在不同的类之间，子类和父类之间

·重载的函数需要与原函数有相同的函数名、不同的参数列表，不关注函数的返回值类型；重写的函数的函数名、参数列表和返回值类型都需要和原函数相同，父类中被重写的函数需要有 virtual 修饰

·virtual 关键字：重写的函数基类中必须有 virtual 关键字的修饰，重载的函数可以有 virtual 关键字的修饰也可以没有

## （19）C++ 内存管理（热门问题，问过）

参考：🔗 https://blog.csdn.net/caogenwangbaoqiang/article/details/79788368

**C++****内存分区：栈、堆、自由存储区、全局****/****静态存储区、常量区**

栈：存放函数的局部变量，由编译器自动分配和释放

堆：动态申请的内存空间，就是由 malloc 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收

自由存储区：和堆十分相似，存放由new分配的内存块，由delete释放内存

全局区/静态区：存放全局变量和静态变量

常量存储区：存放的是常量，不允许修改

**堆和自由存储区的区别：**

参考链接：🔗 https://www.cnblogs.com/qg-whz/p/5060894.html

·自由存储是 C++ 中通过new与delete动态分配和释放对象的抽象概念，而堆是C语言和操作系统的术语，是操作系统维护的一块动态分配内存

·new 所申请的内存区域在 C++ 中成为自由存储区。即由堆实现的自由存储，可以说new所申请的内存区域在堆上

·堆和自由存储区有区别，并非等价。使用new来分配内存，程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了。

**指针和数组的对比：**

1、字符数组的内容可以改变，字符指针的内容不可以改变

char a[] = "hello";

a[0] = 'l';          //正确

char *p = "world";   //p指向常量字符串

p[0] = 'h';          //运行出错

2、字符数组之间不能赋值，不能直接用比较运算符直接比较，若进行赋值调用 strcpy() 函数，若进行比较调用 strcmp() 函数；

char a[] = "hello";

char b[10];

strcpy(b, a);           //不能用b = a;

if(strcmp(a, b) == 0)     //不能用a == b

​    cout << "endl";

3、运算符 sizeof 可以计算出字符数组的容量，但是计算字符指针时，得到的是指针变量所占用的空间，而不是指针所指向空间的大小。

char a[] = "hello";

char *p = a;

cout << sizeof a << endl;     //6字节

cout << sizeof p << endl;    //8字节（64位）

但是当数组作为参数传递时，数组会自动退化为指针

void fun(char a[100]){

​    cout << sizeof a << endl;//结果是8（64位）

}

**调用函数申请空间**

1、指针作为函数的参数传递：

void GetMemory(char *p, int num) {

　p = (char *)malloc(sizeof(char) * num);

}

void Test(void) {

　char *str = NULL;

　GetMemory(str, 100); // str 仍然为 NULL

　strcpy(str, "hello"); // 运行错误

}

上述程序出错的原因在于：调用函数时，传递的是变量的值“值传递”，在 GetMemory 函数内部改变的是参数p的副本，并不会影响参数p本身，也就是说 str 并没有获得内存。这样程序最终会导致内存泄漏，调用 GetMemory 函数多少次，就会出现多少次内存泄漏，因为在函数内部只动态申请了内存，并没有用free释放掉动态内存空间。

如果想要通过这种方式申请空间，将 GetMemory 函数的形参改为“指向指针的指针”

void GetMemory2(char **p, int num) {

　*p = (char *)malloc(sizeof(char) * num);

}

void Test2(void) {

　char *str = NULL;

　GetMemory2(&str, 100); // 注意参数是 &str，而不是str

　strcpy(str, "hello");

　free(str);//特别注意：这里是将动态申请的内存空间释放掉

}

2、用函数的返回值来传递动态申请的内存空间

| char  *GetString(void) {  　char p[] = "hello world";  　return p; // 编译器将提出警告：将局部变量返回  } | char  *GetString2(void) {  　char *p = "hello world";  　return p;//编译器给出警告：将string const转化成 char*  } |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| void  Test4(void) {  　char *str = NULL;  　str = GetString(); // str 的内容是垃圾  　cout<< str << endl;  } | void  Test5(void) {  　char *str = NULL;  　str = GetString2();  　cout<< str << endl;  } |

**在一个函数中如何返回一个变量的指针？**

对于普通变量而言，是存储在栈内存中，当函数调用完毕后，栈内存的空间会被释放，如果返回局部变量的指针，回到主调函数后，该指针是悬挂指针指向垃圾内存，如何来处理这种情况呢？

可以返回存储在堆内存或者全局区的变量的指针：

·返回静态类型对象的指针，会导致占用大量的内存空间

·返回存放在堆上的对象的指针，该对象所在的内存空间由用户控制什么时候释放，那如何知道什么时候释放合适呢？可以用只智能指针来处理，智能指针内部有计数器，当计数器为 0 时，会自动释放该内存。

| int func1(int  param) {   int local_param = param;   return local_param;  } | //返回静态变量的地址   int*  func2(int param) {   static int local_param = param;   return &local_param;  } | //返回存放在堆上变量的地址*   int  *func3(int param) {   int *new_param = new int(param);   return new_param;  } |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
|                                                              |                                                              |                                                              |

int main() {

 int *pNewVar = func3(3);

 int *pVar = func2(2);

 cout << *pVar << endl;//2

 cout << *pNewVar << endl;//3

 cout << func1(1) << endl;

 return 0;

}

**出现野指针的情形：**

1、指针定义的时候未初始化

2、指针指向动态分配的内存空间在释放（delete或free）后，未置为 NULL，让人误以为是合法指针

3、指针操作超过了变量的作用范围。例如：在函数中将一个局部变量的地址作为函数的返回值，这里编译器会给出警告，因为离开该函数后，局部变量的空间就会释放掉，返回的地址（指针）相当于是野指针。

**深拷贝和浅拷贝带来的问题：**

类中默认的拷贝构造函数和赋值构造函数都是浅拷贝，当类的成员变量中出现指针变量时，最好使用深拷贝，避免内存空间多次释放的问题出现。

**内存泄漏：**

内存泄漏常指的是堆内存泄漏，当然还包括系统资源的泄漏

参考链接：🔗 https://blog.csdn.net/bl520025/article/details/8967648

**野指针：** 指针指向的内存空间已经释放掉

**悬挂指针：** 指针指向的内存空间由于中间改变了其指向，之前的内存空间已无法释放，个人认为是和内存泄漏。

感觉二者并没有什么区别！！！！

野指针和悬挂指针都是指向垃圾内存的

 

本篇中知识点小结：

·类大小的计算

·STL 相关知识点：hash表的实现原理，vector的实现原理，vector使用注意的地方，unordered_map和map的区别

·重载和重写的区别

·内存管理：内存分区，堆和自由存储区的区别，指针和数组的比较，内存泄漏深拷贝和浅拷贝，悬挂指针和野指针

 

# 2021 秋招面经总结 —— C++ 篇（三）

## （20）面向对象和面向过程的区别（问过）

**·面向过程：** 以事件为中心的编程思想，编程时把解决问题的**步骤**分析出来，然后用**函数**把这些步骤实现，在一步一步的具体步骤中再按顺序调用函数

**·面向对象**： 世界上有很多的人和事物，每一个都可以看作一个对象，每个对象都有自己的**属性**和**行为**，对象和对象之间可以通过方法来交互，对象的抽象称为类

## （21） 什么是面向对象，介绍面向对象的三大特性，并且举例说明每一个。

面向对象：对象是指具体的某一个事物，这些事物的抽象就是类，类中包含数据（成员变量）和动作（成员方法）。

·封装：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。

·继承：子类继承父类的特征和行为，子类有父类的非private方法或成员变量，子类可以对父类的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被final关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。

·多态：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式

## （22） 多态的实现和应用场景

多态通过虚函数实现

应用场景：在实际开发中，一个功能有多种实现方式，流程相同，但是具体的细节有区别，例如：支付功能，可以进行支付宝支付、微信支付等

## （23） C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）

虚函数是通过虚函数表来实现的，虚函数表里面保存了虚函数的地址，这张表保存在含有虚函数的类的实例对象的内存空间中，虚函数表的指针存放在对象实例的最前面的位置.

虚函数表是在编译阶段建立的，也就是说在程序的编译过程中会将虚函数的地址放在虚函数表中。（问过）

## （24）虚继承（和虚函数混合在一起问）

**提出：**

虚继承是为了解决**多重继承**中**命名冲突**和**数据冗余**问题而提出的。例如：类D继承类B1,B2，而类B1,B2都继承自类A，因此在类D中出现两次类A中的变量和函数，那为了节省内存空间可以将B1,B2对A的继承定义为虚继承，而A就成了虚基类。

![img](file:///C:/Users/原来是~1/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg)

 

class A{};

class B1:public virtual A{};

class B2:public virtual A{};

class D:public B1,public B2{};

这样使用虚继承就能够确保在派生类D中只保存一份A的成员变量和成员函数。

虚继承的目的是让某个类做出声明，承诺愿意共享它的基类，这个被共享的基类就称为虚基类。

**虚基类的成员可见性问题：**

假设A中定义了一个名为x的成员变量，当我们直接访问x时，会有三种可能：

·如果B1,B2中都没有定义x，那么x将被解析为A的成员，不存在二义性；

·如果B1或B2其中的一个类定义了x，那么也不存在二义性的问题，派生类的x比虚基类的x的优先级更高；

·如果B1和B2中都定义了x，那么直接访问x会产生二义性问题

## （25） 实现编译器处理虚函数表应该如何处理

·编译器将虚函数表的指针放在类的实例对象的内存空间中，该对象调用该类的虚函数时，通过指针找到虚函数表，根据虚函数表中存放的虚函数的地址找到对应的虚函数。

·如果派生类没有重新定义基类的虚函数A，则派生类的虚函数表中保存的是基类的虚函数A的地址，也就是说基类和派生类的虚函数A的地址是一样的

·如果派生类重写了基类的某个虚函数B，则派生的虚函数表中保存的是重写后的虚函数B的地址，也就是说虚函数B有两个版本，分别存放在基类和派生类的虚函数表中

·如果派生类重新定义了新的虚函数C，派生类的虚函数表保存新的虚函数C的地址

## （26） 析构函数一般写成虚函数的原因

析构函数定义成虚函数是为了**防止内存泄漏**，因为当父类的指针或者引用指向或绑定到子类的对象时，如果未将基类的析构函数定义成虚函数，会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中特有的就会无法释放内存空间导致内存泄漏。

## （27） 构造函数为什么一般不定义为虚函数

·从存储空间的角度考虑，构造函数是在实例化对象的时候进行调用，如果此时将构造函数定义成虚函数，需要通过访问该对象所在的内存空间才能进行虚函数的调用（因为需要通过指向虚函数表的指针调用虚函数表，虽然虚函数表在编译时就有了，但是没有虚函数的指针，虚函数的指针只有在创建了对象才有），但是此时该对象还未创建，便无法进行虚函数的调用。所以构造函数不能定义成虚函数。

·从使用的角度来看，虚函数是基类的指针指向派生类的对象时，通过该指针实现对派生类的虚函数的调用，构造函数是在创建对象时自动调用的

·从实现上来看，虚函数表是在创建对象之后才有的，因此不能定义成虚函数

·从类型上来看，在创建对象时需要明确其类型

 

本篇涉及的知识点大多是和面向对象中的类相关的，笔者认为这也是C++中的重点。当然面经对问题的答案描述的比较精简，想更深刻的掌握知识点的精髓建议翻翻书看看，毕竟书中的语言更加严谨。

 

# 2021 秋招面经总结 —— C++ 篇（四）

## （28） 构造函数或者析构函数中调用虚函数会怎样

参考：https://blog.csdn.net/henrytien/article/details/80064863

·程序可以正常运行

·但是无法达到虚函数调用的效果，当用基类的指针指向派生类的对象时，在调用基类的构造函数时，若出现虚函数的调用，程序的本意是调用派生类中的虚函数，但是当虚函数出现在构造函数或者析构函数中时，调用的是其所在类（基类）的虚函数。**派生类对象构造期间进入基类的构造函数时，对象的类型变成了基类类型，而不是派生类类型。同样进入基类析构函数时，对象也是基类类型。**

## （29） 纯虚函数

·纯虚函数在类中声明时，加上=0，

·含有纯虚函数的类称为抽象基类（只要含有纯虚函数这个类就是抽象类），类中只有接口，没有具体的实现方法

·继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，依然是抽象类，不能实例化对象。

抽象类对象不能作为函数的参数，不能创建对象，不能作为函数返回类型；

抽象类可以声明为抽象类指针，可以声明抽象类的引用；

子类必须继承父类的纯虚函数，并全部实现后，才能创建子类的对象。

## （30） 静态绑定和动态绑定的介绍

**静态类型和动态类型：**

·静态类型：变量在声明时的类型，是在**编译期**确定的。静态类型不能更改

·动态类型：目前所指对象的类型，是在**运行期**确定的。动态类型可以更改

**静态绑定和动态绑定：**

·静态绑定是指程序在**编译的过程中**确定对象的类型（静态类型）

·动态绑定是指程序在**运行期间**确定对象的类型（动态类型）

**静态绑定和动态绑定的区别：**

·发生的时期不同：如上

·对象的静态**类型**不能更改，动态类型可以更改

·要想实现**多态**，必须进行动态绑定

·在继承体系中，只有**虚函数**是动态绑定，其他都是静态绑定

**编译时多态和运行时多态（面试时问过）：**

·编译时多态：在程序编译过程中出现，发生在**模板**和**函数重载**中（泛型编程）

·运行时多态：在程序运行过程中出现，发生在**继承**体系中，是指通过基类的指针或引用访问派生类中的虚函数

**编译时多态和运行时多态的区别：**

·编译时多态发生在程序编译过程中，运用泛型编程来实现，在编译时完成，提升程序的运行效率，但是对于无法实现模板的分离编译对于大程序编译时十分耗时

·编译时多态无法处理异质对象的集合（异质对象是通过异质类定义的，异质类是指存储类型不一致的数据对象）

·运行时多态体现了面向对象的特征，但是虚函数会占用一定的存储空间

·运行时多态发生在程序的运行过程中，编译器无法进行优化处理

引申出：**显示接口和隐式接口**

·显示接口：能够明确来源的接口，例如在运行时多态中，能够明确的知道所调用的函数是来源于哪个类

·隐式接口：无法确定来源的接口，例如对于函数重载和模板，不知道是调用哪个实现

## （31） 引用是否能实现动态绑定，为什么引用可以实现

参考链接：https://www.cnblogs.com/fandingBlog/p/3918407.html

能够实现动态绑定，因为对象的类型是确定的，引用时在运行阶段根据他们绑定的具体对象的类型确定的。

最根本的原因在于：多态是通过虚函数实现的，而虚函数是通过存储在对象的内存空间中的指针调用的；

·当基类的指针指向派生类的对象时，向上进行类型转化的是地址，此时派生类的对象中指向虚函数的指针并不会发生变化，只是改变了基类指针的地址，因此可以实现多态

·当派生类的对象赋值给基类的对象，此时派生类对象的指向虚函数的指针会发生变化（隐式的向上转化），变为基类的对象的虚函数的指针，因此无法实现多态

## （32） 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）

参考：https://blog.csdn.net/liitdar/article/details/81904009

如果一个类拥有资源，该类的对象发生了复制，如果资源发生了重新分配，就是深拷贝，否则就是浅拷贝

·深拷贝：该对象和原对象占用不同的存储空间，即拷贝位于stack域（栈）中的内容，又拷贝类中位于heap域（堆）中的内容

·浅拷贝：该对象和原对象占用同一块内存区域，仅拷贝类中位于stack域（栈）中的内容

当类的成员变量中有指针时，使用深拷贝安全，如果两个对象指向同一块内存空间，当其中一个对象的删除后，该块内存空间就会被释放，另外一个对象指向的就是垃圾内存。

## （33） 对象复用的了解，零拷贝的了解(没问到过)

·零拷贝：不需要cpu参与在内存之间复制数据的操作

·对象的复用：享元模式，通过创建一个对象池，以避免对象的重复创建

## （34） 介绍C++所有的构造函数

构造函数的作用：当创建对象时，系统分配了内存空间后，会自动调用相应的构造函数

·默认构造函数：没有参数，如果创建了一个类，没有定义任何构造函数，系统会自动生成默认的构造函数

·一般构造函数：带有参数，一个类可以有若干个一般构造函数，前提是参数的数量或者类型不同（C++重载函数原理）

·拷贝构造函数：参数为该类的常量引用对象，如果类中没有定义拷贝构造函数，系统会默认生成一个默认的拷贝构造函数，默认生成的拷贝构造函数都是浅拷贝的

·赋值构造函数：区别于以上构造函数，以上构造函数都没有函数的返回类型，这里虽然称为“赋值构造函数”，其实是“重载了赋值运算符的函数”，该函数的返回类型是该类的引用类型，参数是该类的常量引用对象。

**拷贝构造函数（复制）和赋值构造函数（赋值）的区别：**

参考链接：https://blog.csdn.net/liitdar/article/details/81904009

·二者的参数类型都是该类的常量引用对象，但是，拷贝构造函数没有返回类型，赋值构造函数的返回类型是该类的引用类型

·在实现过程中，调用拷贝构造函数是在创建一个新的对象时，所以在函数内直接申请空间(heap)然后给相应的成员变量赋值即可；调用赋值构造函数时，源对象和目标对象都已声明，所以在函数内需要将目标对象的内存空间（heap）释放掉，重新申请空间，再进行拷贝操作

·二者的使用场景不同，拷贝构造函数的使用场景见如下三种情况

## （35） 什么情况下会调用拷贝构造函数（三种情况）

参考：https://blog.csdn.net/liitdar/article/details/81877373

·创建类的对象时，有两种情形：**代入法** classA obj(1,2)；**赋值法** classB obj1 = obj

·当类的对象作为**函数的参数**时，由实参到形参的复制过程会调用拷贝构造函数

·当类的对象作为**函数的返回值**时，会将返回值通过调用拷贝构造函数复制给一个临时对象，并传到函数的调用处

 

不得不说，C++的知识点还是蛮多的，但是功夫不负有心人，耐心复习，总会把面试中的高频知识点吃透。但提醒大家一点，刚开始复习的时候，注重知识的广度，不能说我只会虚函数，无论问我虚函数相关的什么知识点我都能答上来，包括虚函数的实现原理，虚函数表等等，但是问我智能指针就一问三不知了。随着复习的遍数增加，每复习以一遍，建议增加复习的深度，可能第一遍仅停留在概念层面，那么第二面就要关注下原理，第三遍呢就要看下源代码。

 

# 2021 秋招面经总结 —— C++ 篇（五）

## （36） 结构体内存对齐方式和为什么要进行内存对齐？（问到过）

参考链接：https://blog.csdn.net/sweetfather/article/details/78487563

结构体的大小并不是各数据成员之和，而是按照一定的对齐数进行对齐存储，最后结构体的大小也是按照一定的对齐数进行对齐。

**对齐规则：**

·第一个成员在与结构体变量偏移量为0的地址

·其他成员变量要对齐到对齐数字的整数倍地址处

·对齐数 = 编译器默认的对齐数（vs:8,linux:4）与该成员大小较小的值

·结构体总的大小为默认对齐数的整数倍

注意一点：当内存中的变量变换了顺序后，那么该结构体对象或者该类的对象所占的内存空间也会发生变化。

 

class MyStruct {

  char dda;  //偏移量为0，满足对齐方式，dda占用1个字节；

  double dda1; //下一个可用的地址的偏移量为1，不是sizeof(double)=8的倍数，需要补足7个字节才能使偏移量变为8（满足对齐方式），因此VC自动填充7个字节，dda1存放在偏移量为8的地址上，它占用8个字节。

  int type;  //下一个可用的地址的偏移量为16，是sizeof(int)=4的倍数，满足int的对齐方式，所以不需要VC自动填充，type存放在偏移量为16的地址上，它占用4个字节。

  //共占20个字节，不是默认偏移量（8）的整数倍，需要进行字节填充，最终占24个字节

};

 

class MyStruct1{

  double d1;//偏移量0，满足对齐方式，d1占用8个字节

  char d2;//偏移量为8，满足对其方式（是1的倍数），占用1个字节

  int d3;//偏移量为9，不满足对其方式（不是4的倍数），需要补3个字节，9+3+4=16

  //最终，占16个字节，是默认偏移量（8）的整数倍，不用补充字节

};

int main() {

  cout << sizeof(MyStruct) << endl;

  cout << sizeof(MyStruct1) << endl;

  return 0;

}

 

**进行内存对齐的原因：**

·平台的移植性好，并不是所有的硬件平台都能存放任意地址的数据，某些平台只能在某些地址访问特定类型的数据，否则就会出现异常

·cpu处理效率高：cpu并不是把内存看成以字节为单位，而是以块为单位，cpu在读取内存的时候是一块一块的读取的

## （37） 内存泄露的定义，如何检测与避免？

**内存泄漏：**由于疏忽或错误导致程序未能释放掉不再使用的内存，并不是说这块内存在物理上消失，而是说失去了对这块内存的**控制**，因而造成了内存的浪费

**检测**内存泄漏的方法：

·使用工具软件BoundChecker

·运行DEBUG版程序，运用以下技术：CRT(C Run-time libraries)、运行时函数调用堆栈、内存泄漏时提示的内存分配序号，综合分析内存泄漏的原因

**解决**内存泄漏的方法：**智能指针**

## （38） 智能指针

智能指针是为了解决动态内存分配时带来的内存泄漏以及多次释放同一块内存空间而提出的。

·共享指针（shared_ptr）：资源可以被多个指针共享，使用计数机制表明资源被几个指针共享。通过use_count()查看资源的所有者的个数，当该变量的值变为0后，会自动释放内存空间，从而避免了内存泄漏。

·独占指针（unique_ptr）：资源只能被一个指针占有，该指针不能拷贝构造和赋值

·弱指针（weak_ptr）：指向share_ptr指向的对象，能够解决由shared_ptr带来的循环引用问题

**weak_ptr****如何解决****shared_ptr****的循环引用问题？（问过）**

循环引用：该被调用的析构函数没有被调用，从而出现了内存泄漏

·weak_ptr对被shared_ptr管理的对象存在非拥有性（弱）引用，在访问所引用的对象前必须先转化为shared_ptr

·-weak_ptr用来打断shared_ptr所管理对象的循环引用问题，若这种环被孤立（没有指向环中的外部共享指针），shared_ptr引用计数无法抵达0，内存被泄露； 能令环中的指针之一为弱指针可以避免该情况

·weak_ptr用来表达临时所有权的概念，当某个对象只有存在时才需要被访问，而且随时可能被他人删除，可以用weak_ptr跟踪该对象；需要获得所有权时将其转化为shared_ptr，此时如果原来的shared_ptr被销毁，则该对象的生命期被延长至这个临时的shared_ptr同样被销毁

**智能指针的实现：**

 

\#include <iostream>

\#include <memory>

 

template <typename T>

class SmartPtr {

private : T *_ptr;

  size_t *_count;

public:

  SmartPtr(T *ptr = nullptr) : _ptr(ptr) {

​    if (_ptr) {

​      _count = new size_t(1);

​    } else {

​      _count = new size_t(0);

​    }

  }

 

  ~SmartPtr() {

​    (*this->_count)--;

​    if (*this->_count == 0) {

​      delete this->_ptr;

​      delete this->_count;

​    }

  }

 

  SmartPtr(const SmartPtr &ptr) {         //拷贝构造

​    if (this != &ptr) {

​      this->_ptr = ptr._ptr;

​      this->_count = ptr._count;

​      (*this->_count)++;

​    }

  }

 

  SmartPtr &operator=(const SmartPtr &ptr) {  //赋值运算符重载

​    if (this->_ptr == ptr._ptr) {

​       return *this;

​    }

​    if (this->_ptr) {

​      (*this->_count)--;

​      if (this->_count == 0) {

​        delete this->_ptr;

​        delete this->_count;

​      }

​    }

​    this->_ptr = ptr._ptr;

​    this->_count = ptr._count;

​    (*this->_count)++;

​    return *this;

  }

 

  T &operator*() {

​    assert(this->_ptr == nullptr);

​    return *(this->_ptr);

  }

 

  T *operator->() {

​    assert(this->_ptr == nullptr);

​    return this->_ptr;

  }

 

  size_t use_count() {

​    return *this->count;

  }

};

## （39） 调试程序的方法，（程序异常退出如何排查，问到过）

·IDE设置断点进行调试

·Linux中没有IDE，可以打印log

·打印中间结果

·生成core文件

## （40） 遇到coredump要怎么调试（问过）

参考链接：https://blog.csdn.net/zhu2695/article/details/51512138

·打开生成core文件的开关ulimit -c unlimited

·输入gdb core文件名 core

·输入where命令，可以找到错误的根源

## （41） 内存检查工具的了解

参考链接：https://blog.csdn.net/gatieme/article/details/51959654

## （42） 模板的用法与适用场景

在C++11中模板新加了一些的特性，模板分为类模板和函数模板

·函数模板：在定义一个函数时，可以用指定的关键字来代替其类型，template<typename T> + 函数头（例如：void cmp(const T &a, const T& b)）

·类模板：和函数模板类似，在定义一个类时，将成员变量的类型用一个指定的关键字来代替，template<class T> + 类定义（class A{}）

使用场景： 参考链接：https://www.cnblogs.com/liguangsunls/p/7247006.html

·数据类型和算法相分离的**泛型编程**

## （43） 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？

参考链接：https://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html

成员初始化列表用来完成类中成员函数的初始化操作，初始化的顺序和在类中声明的顺序有关。

·对于内置类型而言，在构造函数中使用初始化列表和在构造函数体中进行赋值，性能没什么差别

·但是对于自定义类型而言，使用初始化列表可以使变量在初始化的时候直接调用拷贝构造函数即可；如果是在函数体中进行赋值，会先调用默认的构造函数创建该对象，然后调用赋值构造函数进行赋值。

## （44） 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）

·智能指针

·lambda表达式

·模板、泛型编程

## （45） C++的调用惯例（简单一点C++函数调用的压栈过程）

将参数压栈，然后压入函数返回地址，进行函数调用，通过跳转指令进入函数，将函数内部的变量去堆或栈上开辟空间，执行函数功能，执行完成，取回函数返回地址，进行接下来的执行过程

## （46） C++的四种强制转换

参考链接：https://www.cnblogs.com/Allen-rg/p/6999360.html

·static_cast：用于**数据**的强制类型转换，强制将一种数据类型转换为另一种数据类型

1.用于基本数据类型的转换

2.用于类层次之间的基类和派生类之间指针或者引用的转换（不要求必须包含虚函数，但必须是有相互联系的类），进行上行转换（派生类的指针或引用转换成基类表示）是安全的；进行下行转换（基类的指针或引用转换成派生类表示）由于没有动态类型检查，所以是不安全的，最好用dynamic_cast进行下行转换。

3.可以将空指针转化成目标类型的空指针

4.可以将任何类型的表达式转化成void类型

·const_cast：强制**去掉常量属性**，不能用于去掉变量的常量性，只能用于去除指针或引用的常量性，将常量指针转化为非常量指针或者将常量引用转化为非常量引用（注意：表达式的类型和要转化的类型是相同的）

 

int main() {

  const int a = 10;

  const int * p = &a;

  int *q;

  q = const_cast<int *>(p);

  *q = 20;  //fine，去掉指针的常量属性去改变指针所指向的常量的值，虽然指向的是同一内存空间，但是常量的值不会发生变化

  cout <<a<<" "<<*p<<" "<<*q<<endl;//输出：10 20 20

  cout <<&a<<" "<<p<<" "<<q<<endl;//输出：0x23fe2c 0x23fe2c 0x23fe2c

  return 0;

}

·reinterpret_cast：改变指针或引用的类型、将指针或引用转换为一个足够长度的整型、将整型转化为指针或引用类型

·dynamic_cast：

1.其他三种都是编译时完成的，动态类型转换是在程序运行时处理的，运行时会进行类型检查

2.只能用于带有虚函数的基类或派生类的指针或者引用对象的转换，转换成功返回指向类型的指针或引用，转换失败返回NULL；不能用于基本数据类型的转换

3.在向上进行转换时，即子类的指针转换成父类的指针和static_cast效果是一样的，（注意：这里只是改变了指针的类型，指针指向的对象的类型并未发生改变）

 

class A {

  public:

  virtual void f() {

​    cout<<"hello"<<endl;

​    };

};

 

class B:public A{

  public:

  void f() {

​    cout<<"hello2"<<endl;

​    };

};

 

class C {

 void pp() {

   return;

 }

};

 

int fun(){

  return 1;

}

 

int main() {

  A* a1=new B;//a1是A类型的指针指向一个B类型的对象

  A* a2=new A;//a2是A类型的指针指向一个A类型的对象

  B* b=new B;

  C* c;

 

  //向上类型转换,只是改变了b指针的类型，其所指对象的类型并未发生改变,依然是指向B类型的对象

  a2=dynamic_cast<A*>(b);

  if(a2==NULL) {

​    cout<<"null"<<endl;

  } else {

​    cout<<"not null"<<endl;//输出

  }

  a2->f();//输出hello2,因为b自身指向的对象的类型就是B类型

  b->f();//输出hello2

  //向下转换：指针所指向的对象类型和要转换成的指针类型不相同-->转换失败

  b=dynamic_cast<B*>(a2);//此时a2指向的对象的类型已经发生了改变，正好和b指向的对象类型相同（成功）

  if(b==NULL) {

​    cout<<"null"<<endl;

  } else {

​    cout<<"not null"<<endl;//输出

  }

  return 0;

}

输出结果：

not null

hello2

hello2

not null

4.在下行转换时，父类的指针类型转化为子类的指针类型，只有当要转换的指针指向的对象类型和转化以后的对象类型相同时，才会转化成功

class A 

  public:

  virtual void f() {

​    cout<<"hello"<<endl;

​    };

};

 

class B:public A{

  public:

  void f() {

​    cout<<"hello2"<<endl;

​    };

 

};

 

class C{

 void pp() {

   return;

 }

};

 

 

 

int fun(){

  return 1;

}

 

int main(){

  A* a1=new B;//a1是A类型的指针指向一个B类型的对象

  A* a2=new A;//a2是A类型的指针指向一个A类型的对象

  B* b;

  C* c;

  //向下转换：指针所指向的对象类型和要转换成的指针类型相同-->转换成功

  b=dynamic_cast<B*>(a1);//结果为not null，向下转换成功，a1之前指向的就是B类型的对象，所以可以转换成B类型的指针。

  

  if(b==NULL) {

​    cout<<"null"<<endl;

  } else {

​    cout<<"not null"<<endl;

  }

  a1->f();

  //向下转换：指针所指向的对象类型和要转换成的指针类型不相同-->转换失败

  b=dynamic_cast<B*>(a2);//结果为null，向下转换失败

  if(b==NULL) {

​    cout<<"null"<<endl;

  } else {

​    cout<<"not null"<<endl;

  }

 

  c=dynamic_cast<C*>(a1);//结果为null，向下转换失败

  if(c==NULL) {

​    cout<<"null"<<endl;

  }

 

  else {

​    cout<<"not null"<<endl;

  }

  delete(a1);

  return 0;

}

输出结果：

not null

hello2

null

null

 

# 2021 秋招面经总结 —— C++ 篇（六）

## （47）函数指针和指针函数

参考链接：https://blog.csdn.net/qq_31672701/article/details/108566678

·函数**指针**（指向函数的指针）：本质上是一个指针，只不过这个指针指向了一个函数，保存的是这个函数的地址（函数名）。int (*p)(int, int)//表示所指向的函数返回值是int型，参数是两个int型

·指针**函数**（函数的返回值是指针）：本质上是一个函数，只不过返回值是指针类型。int* fun(int x, int y){}//这个fun函数的返回值是指针类型

## （48）构造函数的调用次数

注意：有一个类A，

·如果定义该类型的一个数组A t[5];数组长度是几，就会调用几次构造函数

·如果定义该类型的指针数组A *p[5];不会调用构造函数，这里数组中存放的是指向A类型的对象的指针

## （49）析构函数和构造函数的调用顺序

\#include <iostream>

using namespace std;

//之前定义了class A、class B、class C、class D

C c;

int main(){

  A *pa = new A();

  B b;

  static D d;

  delete pa;  

  return 0;

}

运行结果：

C construct;

A construct;

B construct;

D construct;

A destruct;

B destruct;

D destruct;

C destruct;

解释：

·A先析构的原因在于调用了delete A，

·当离开函数的作用域时，也就是执行到main函数的右括号时，会释放存放在栈内存的空间，会将局部变量b析构掉

·当程序执行完毕时，会释放存放在全局区的变量，先释放d，因为d是后构造的；再释放c。（变量c是全局变量，在调用main函数之前进行构造）

## （50）auto和decltype的区别

auto和decltype都用于类型推导：

·语法格式不同：auto var = value; decltype(表达式) var2 [= value];

auto根据=右面的初始值value推导出变量var的类型；decltype根据后面括号中的表达式推导出变量的类型，和=右面的value没有关系；

·auto要求变量必须初始化，即定义变量的时候必须赋值；decltype将变量的类型和初始值分开

## （51）哪些运算符不能重载

参考链接：http://c.biancheng.net/cpp/biancheng/view/2188.html

C++中绝大部分运算符都能重载。

不能重载的运算符（只有5个）：

·. 成员访问运算符 ，保证访问成员的功能不能被改变

·.* 成员指针访问运算符，保证访问成员的功能不能被改变

·:: 域运算符，运算对象是类型而不是变量

·sizeof 长度运算符，运算对象是类型而不是变量或一般表达式，不具备重载特征

·?: 条件运算符，运算对象是类型而不是变量或一般表达式，不具备重载特征

## （52） 运算符重载函数声明为一般函数还是友元函数，以及运算符重载的一些注意事项

参考链接：https://blog.csdn.net/KingCat666/article/details/44870799

·运算符重载可以重载为类的成员函数，也可以是类的友元函数。

·一般情况下，单目运算符重载为类的成员函数，双目运算符重载为类的友元函数

**注意事项：**

·有五种不能重载的运算符："." , ".*", "::", "sizeof", "?:"

·重载的运算符必须限制在可重载的运算符之中，不能创造新的运算符

·遵循函数重载的原则，但是不能有默认的参数

·重载后的运算符不能改变运算符的优先级和结合性，也不能改变运算符操作数的个数及语法结构，不能改变内部对象的含义

·自定义类型的运算符一般都先重载后使用，但是"="和“&”可以不用重载

## （53）静态函数能否定义成虚函数

参考链接：https://www.cnblogs.com/lakeone/p/5967548.html

**静态成员函数不能被声明为虚函数：**

·静态成员不属于任何类对象或类实例，所以即使加上virtual也没有任何意义

·静态与非静态成员函数之间一个最主要的区别就是：静态成员函数没有this指针。调用类中的虚函数时，是通过虚表以及指向虚表的指针vptr才能完成虚函数的调用，并且只能用this指针来访问。对于静态成员函数没有this指针，无法访问vptr.

**静态成员函数不能为****const****函数：**

·当声明一个类（Test）的非静态成员函数为const时，this指针相当于Test const *，对于非const成员函数，this指针相当于Test *. 但是static成员函数没有this指针，所以用const来修饰static没有任何意义。（volatile的道理也是如此）

 

面经 C++ 篇就到此结束了，当然不可避免的有些知识点未涉及到，建议大家在复习的过程中，以此作为参考，并不断地将其中没有涉及的知识点收纳在自己的知识库中，多复习多巩固，向更深入的方向努力。面试过程中，永远想象不到面试官会挖的多深！

 

# 2021秋招面经总结——STL篇（上）

笔者秋招投递的岗位主要是软件开发C++方向和后端开发，面试过程中主要的编程语言是C++，准备面C++方向的小伙伴，一定一定要看下STL源码，可能短时间内达不到手写源码的程度，但一些数据结构的底层原理一定要搞明白，面试过程中一些互联网大厂的面试官超级喜欢问。建议看下《STL源码剖析》这本书，但注意没必要面面俱到，可以重点看点各种数据结构设计的底层原理，当然其他部分面试过程中也完全有可能涉及。

## 整体框架：STL六大组件

1、**容器**：各种数据结构，从实现的角度来看，STL容器是一种class template

![img](file:///C:/Users/原来是~1/AppData/Local/Temp/msohtmlclip1/01/clip_image006.jpg)

2、**空间配置器**：负责动态空间的配置和管理

3、**迭代器**：在23个设计模式中，有一种是迭代器模式（提供一种方法，使之能够依序访问某个容器所含的各个元素，而无需暴露该容器的内部表述方式），其行为类似于智能指针；STL的设计中，将数据容器和算法分开，彼此独立设计，通过迭代器(容器和算法的胶粘剂)将他们撮合在一起。

4、**算法**：从实现角度来看，STL算法是一种function template

5、**仿函数**：也叫函数对象，行为类似于函数；从实现角度来看，仿函数是重载了operator()的class或者class template 。

仿函数分类：以操作数的个数划分：一元仿函数、二元仿函数； 以功能划分：算术运算、关系运算、逻辑运算。

6、**配接器**：用来修饰容器或者迭代器接口

**六大组件的关系：**

![img](file:///C:/Users/原来是~1/AppData/Local/Temp/msohtmlclip1/01/clip_image008.jpg)

## 常用容器的特点及适用情况

·**string**：与vector相似的容器，专门用于存储字符。随机访问快，在尾位置插入/删除速度快

·**array**：固定大小数组。支持快速随机访问，不能添加或者删除元素

·**vector**：可变大小的数组。底层数据结构为数组，支持快速随机访问，在尾部之外的位置插入或者删除元素可能很慢

·**list**：双向链表。底层数据结构为双向链表，支持双向顺序访问。在list任何位置插入/删除速度很快

·**forward_list**：单向链表。支持单项顺序访问。在forward_list任何位置插入/删除速度很快

·**deque**：双端队列。底层数据结构为一个中央控制器和多个缓冲区，支持快速随机访问，在头尾位置插入/删除速度很快

·**stack**：栈。底层用deque实现，封闭头部，在尾部进行插入和删除元素

·**queue**：队列。底层用deque实现

·**priority_queue**：优先队列。底层用vector实现，堆heap为处理规则来管理底层容器的实现

·**set**：集合。底层为红黑树，元素有序，不重复

·**multiset**：底层为红黑树，元素有序，可重复

·**map**：底层为红黑树，键有序，不重复

·**multimap**：底层为红黑树，键有序，可重复

·**hash_set**：底层为哈希表，无序，不重复

·**hash_multiset**：底层为哈希表，无序，可重复

·**hash_map**：底层为哈希表，无序，不重复

·**hash_multiap**：底层为哈希表，无序，可重复

**总结**：(这里仅代表做这几种操作时效率比较高，可能其他容器也支持这几种操作)

·支持随机访问的容器：string,array,vector,deque

·支持在任意位置插入/删除的容器：list,forward_list

·支持在尾部插入元素：vector,string,deque

**说明：**

总体来说：unordered_map（就是上面所说的hash_map）比map的查找速度快，unordered_map的查找速度是常数级别，map的查找速度是（logn）级别。但是，不一定常数就比logn小，hash还有hash函数耗时。当考虑效率，特别是当元素达到一定数量级时，考虑unordered_map;但如果对内存要求特别严格，希望少消耗内存，当unordered_map对象比较多时，就不太好控制了，而且它的构造速度会比较慢

## 面经总结1————底层原理问题：

·**vector****底层存储机制**

vector是一个动态数组，里面是一个指针指向一片连续的空间，当空间不够用时，会自动申请一块更大的空间（一般是增加当前容量的50%或者100%），然后把原来的数据拷贝过去，接着释放原来的空间；当释放或者删除里面的数据时，其存储空间不释放，仅仅是清空了里面的数据

·**list****底层存储机制**

list以节点为单位存放数据，节点的地址在内存中不一定连续，每次插入或者删除数据时，就配置或者释放一个元素的空间

·**deque****底层存储机制**

deque动态的以分段连续的空间组成，随时可以增加一段新的连续的空间并链接起来，不提供空间保留（reserve）功能。

deque采用一块map(不是STL的map容器)作为主控，其为一小块连续的空间，其中的每个元素都是指针，指向另一段较大的连续空间（缓冲区）

·map底层机制

map以红黑树作为底层机制，红黑树是平衡二叉树的一种，在要求上比AVL树更宽泛。通过map的迭代器只能修改其实值，不能修改其键值，所以map的迭代器既不能是const也不是mutable

红黑树满足以下几个条件：

1、每个节点不是红色就是黑色

2、根节点是黑色

3、红色节点的子节点必须是黑色（不能有连续的红节点）

4、从根节点到NULL的任何路径所含的黑节点数目相同，叶子节点是黑色的NULL节点（注：这里不是我们常说的二叉树中的叶节点，是它的子节点（NULL））

 

本篇是STL相关面试题上篇，后续还会总结出下篇。为了便于复习总结，笔者以知识点而非问题的形式呈现出来，敬请关注！！！

 

# 2021秋招面经总结——STL篇（中）

本篇是接续上篇，在上篇中总结了下STL的整体框架，重点对数据结构的底层原理问题进行整理，中篇继续总结面试中常问的知识点，建议先看下上篇对STL有个整体的认识，再深入到细节进行学习。最好还是看下《STL源码剖析》这本书。

## 面经总结2—迭代器失效问题

**迭代器和指针的区别**

·迭代器不是指针，是**类模板**，表现的像指针，只是模拟了指针的功能，重载了指针的一些操作符，->, * , ++, --等；

·迭代器封装了指针，是一个可遍历STL容器内全部或者部分元素的对象，本质上封装了原声指针，比指针更高级，相当于智能指针

·迭代器返回的是引用，而不是对象的值

**迭代器的种类**

根据移动特性与实施的操作，迭代器被分为五类：

·**Input Iterator**：**只读**迭代器，该迭代器所指的对象，不允许用户改变

·**Output Iterator**：**唯写**

·**Forward Iterator**：允许写入型算法在该迭代器所形成的区间上进行**读写**操作

·**Bidirectional Iterator**：可双向移动

·**Random Acess Iterator**：前三种迭代器支持operator++，第四种迭代器再加上operator--，第五种涵盖所有指针算术能力，包括 p + n, p - n, p[n], p1 - p2, p1 < p2

**为什么****vector****的插入操作会导致迭代器失效？**

vector动态增加空间时，并不是在原空间之后增加新的空间，而是以原来大小的两倍或者原空间加上实际所需的空间的大小另外配置一片较大的空间，释放原来的空间。由于操作改变了空间，所以原来的迭代器失效

**vector****每次****insert****或者****erase****之后，以前保存的迭代器会不会失效？**

·在进行insert时，如果在p位置插入新的元素。当容器有剩余空间，不需要重新分配空间时，p之前的迭代器都有效，p之后的迭代器都失效；当容器重新分配了内存空间，那么所有的迭代器都失效

·进行erase时，erase的位置在p处，p之前的迭代器都有效且p指向下一个元素位置（如果p在尾元素处，p指向无效end无效），p之后的迭代器都无效。

**deque****插入和删除元素，以前保存的迭代器是否失效？**

·在中间插入或者删除元素，将使deque所有的迭代器、引用、指针失效

·在首部或者尾部插入元素可能会使迭代器失效（缓冲区空间已满，需重新分配内存），但不会引起指针或者引用失效

·在首部或者尾部删除元素，只会使指向被删除的元素迭代器失效

**vector****、****list****、****deque****、****map****在****erase(iter)****后迭代器如何变化**

·vector和deque是序列式容器，其内存分别是连续空间和分段式连续空间，删除迭代器iter后，其后面的迭代器都失效了，此时iter指向被删除元素的下一个位置

·list删除迭代器iter时，其后面的迭代器不会失效，将前面和后面连接起来即可

·map删除iter时，只是当前删除的迭代器失效，其后面的迭代器依然有效

## 面经总结3—容器间的对比

**1. vector** **插入删除操作和****list****有什么区别**

·vector插入删除操作需要进行元素的移动，如果vector所存储的对象很大或者构造函数比较复杂，则开销较大，如果是简单的小数据效率优于list

·list插入删除操作需要遍历当前数据，但在首部插入效率很高

**2.** **什么情况下用****list,****什么情况下用****vector**

·当数据对象简单，对象数量变化不大，需要频繁的随机访问时，用vector

·当数据对象复杂，对象的数量频繁变化，频繁的进行插入和删除操作时，用list

**3. deque****和****vector****的区别**

·vector是单向开口的连续区间，deque是双向开口的连续区间（可以在头尾两端进行插入和删除操作）

·deque提供随机访问迭代器，但是迭代器比vector复杂很多

·deque没有提供空间保留功能，也就是没有capacity这个概念，而vector提供了空间保留功能。即vector有capacity和reserve函数，deque 和 list一样，没有这两个函数。

**4. vector****，****list****，****deque****对比**

·vector数据在内存中连续排列，所以随机存取元素的速度最快。但是在除尾部以外的位置删除或者添加元素的时候速度很慢

·list数据是链式存储，不能随机存取。其优势在于在任意位置添加和删除元素

·deque通过链接若干片连续的数据实现的，均衡了以上两容器的特点

**5. hash_map****和****map****的区别？什么时候用****map,****什么时候用****hash_map**

·**构造函数**：hash_map需要hash function以及等于函数，map需要比较函数

·**存储结构**：hash_map以hashtable为底层，map以红黑树为底层

·**查找速度**：总体来说，hash_map查找速度比map快，而且查找速度基本和数据量的大小无关，属于常数级别；map的查找速度是(logn)级别。并不一定常数级别就比（logn）小，hash_map的hash function也会耗时

**二者如何选择：**

·如果考虑效率，特别是元素达到一定的数量级时，用hash_map

·如果考虑内存，或者元素比较少时，用map

**6. hashtable,hash_set,hash_map****的区别**

·hash_set以hashtable为底层，不具有排序功能，能快速查找，其键值就是实值

·hash_map以hashtable为底层，不具有自动排序功能，能快速查找，每一个元素同时拥有键值和实值

**7. map****和****set****的区别**

·相同点：map和set都是c++的关联容器，底层都是红黑树实现的

·元素： map的元素是key-value（键值—实值）对，关键字起到索引的作用，值表示与索引相关联的数据；set的元素是键值，没有实值

·迭代器：map的迭代器既不是const也不是mutable，map允许修改value实值，不允许修改key键值；set的迭代器是const的，不允许修改键值。其原因在于map和set是根据关键字来保证其有序性的，如果允许修改键值，那么首先要删除该键，调节平衡，然后再插入修改后的键值，调节平衡，这样一来破坏了map和set的结构，导致iterator失效。

·下标操作：map支持下标操作，用关键字作为下标访问关键字对应的值，如果关键字不存在，他会自动将该关键字插入；set不支持下标操作

## 面经总结4—map和set的相关问题

**1.** **为什么****map****和****set****插入和删除效率比其他容器高？**

不需要内存的拷贝和移动

**2.** **为什么****map****和****set****每次****insert****后，以前保存的迭代器不会失效？**

因为插入操作只是节点的指针的交换，节点并没有改变，节点的内存没有改变，指向内存的指针也不会改变

**3.** **当数据元素增多时（从****10000****增加到****20000****）****,map****和****set****的查找速度会怎样？**

二者的底层是基于红黑树来实现的，查找的时间复杂度为logn,数据量从10000增加到20000，查找的次数从log10000 = 14 增加到 log20000 = 15，只是增加了1次

**4.** **为什么****map****和****set****不能像****vector****一样有个****reserve****函数来预分配数据**

map和set内部存储的已经不是元素本身了，而是包含元素的一个节点。他们内部使用的配置器不是在声明的时候传入的alloc而是转换后的alloc。

 

学习新知识是细水长流的过程，不可能一口吃个胖子，也不可能看完一篇面经就把全部的知识点搞明白了，STL中篇重点对迭代器失效问题、容器间的对比、map和set相关问题进行了总结，建议时间充裕的同学书和面经搭配着来看。

# 2021秋招面经总结——STL篇（下）

本篇是STL面经总结的最后一部分，建议看本篇之前先看下2021秋招面经总结——STL篇（上）和2021秋招面经总结——STL篇（中），特别是上篇，对STL涉及到的相关数据结构有个整体的认识。然后再深入细节，在上篇中对一些容器的底层原理进行了总结，在中篇对STL的迭代器失效问题、容器间的对比、map和set相关问题进行了整理。本篇中对一些小问题进行了整理。

## 1. list自带排序函数的原理

说明：STL中的sort方法，接收的输入迭代器是支持随机访问的，双向list链表容器的访问方式是双向迭代器，不能够用STL的排序算法。

在list中自己定义的排序算法，有点像是归并排序，它的排序过程是：

·首先将前两个元素合并

·再将后两个元素合并

·然后将这四个元素合并

·重复上述过程，得到8个，16个，……，子序列

·最终将所有的子序列合并得到的就是排序后的序列

时间复杂度：O(nlogn)

**实现方式：**

·定义了类似搬运作用的链表carry以及中转站作用的链表数组counter

·链表数组counter[i]里面存储的元素最多是2^(i + 1),如果存储的数据超过该数字，则把counter[i]里面的数据都合并到counter[i + 1]链表中

·carry负责取出原始链表的第一个数据，以及交换数据

·代码中的fill,表示当前的counter[fill]可处理数据的个数为2^(fill)，指示当前情况下的最后一个存放链表的位置的下一个位置

源码：

![img](file:///C:/Users/原来是~1/AppData/Local/Temp/msohtmlclip1/01/clip_image010.jpg)

源码说明：

当前链表非空时，进入while循环

1、carry负责将原链表的起始节点取出（步骤1）；如果内层的while循环条件不满足，直接将carry链表的内容转移到counter[0]处（步骤4），（注：当处理原始链表第一个节点，以及counter[0]为空的时候，不会进入内层while循环，内层while循环主要进行counter数组内每个链表合并的过程）

2、内层while循环条件（步骤2，3），该内层循环是counter数组内链表合并的过程，carry在这其中相当于个中间变量。首先，将carry合并到counter[i]中，然后将counter[i]中的内容放到carry中，并且i + 1,直到 i 指向 fill 或者counter[i]为空的时候循环结束

3、将carry中的链表转存到counter[i]中（步骤4）

4、如果当前 i 指向了fill, fill + 1，指示当前情况下的最后一个存放链表的位置的下一个位置

5、最终，将所有的counter中的链表从前往后合并（步骤6）

6、将合并后的链表（在counter[fill - 1]中）放到this里面（步骤7）

## 2.不允许有遍历行为(不提供迭代器)的容器有哪些？

·queue：只能获取头部元素，不能获取其他地方的元素

·stack：只能获取顶端的元素

·heap：所有的元素必须遵循遍历规则，不能遍历

## 3.vector中erase方法和algorithm中remove方法的区别

·vector中erase方法是真正删除了元素，迭代器不能访问了

·remove只是将元素移动到容器的最后面，迭代器还是可以访问到。因为remove只是通过迭代器访问容器，并不知道容器的内部结构，所以无法进行真正的删除。例如序列[0,1,0,2,0,3,0,4],如果执行remove()希望移除所有的0，执行结果将是[1,2,3,4, 0,3,0,4]，每一个和0不想等的元素被拷贝到前四个位置上，第四个位置以后的元素不动

## 4.reserve和resize的区别

·resize(size_type n, value_type val = value_type())：改变的是当前容器内元素的数量，也就是改变的size()。如果n小于当前容器的元素数量，则容器中只会取前n个元素，多余的会被移除；否则会在当前元素的最后插入n - size()个元素，元素的值为其传入的参数，如果未传入，则是默认的

·reserve(size_type n)：改变的是容器的容量，也就是capacity()。如果n大于当前的容量，就会分配空间扩增容量；否则，将不会做任何处理

## 5.STL源码中的hash表的实现

hashtable是采用开链法来完成的，（vector+list）

·底层键值序列采用vector实现，vector的大小取的是质数，且相邻质数的大小约为2倍关系，当创建hashtable时，会自动选取一个接近所创建大小的质数作为当前hashtable的大小；

·对应键的值序列采用单向list实现；

·当hashtable的键vector的大小重新分配的时候，原键的值list也会重新分配，因为vector重建了相当于键增加了，那么原来的值对应的键可能就不同于原来分配的键，这样就需要重新确定值的键。

## 6.STL中unordered_map和map的区别

·底层实现不同：

unordered_map底层实现是一个哈希表，元素无序

map底层实现是红黑树，其内部所有的元素都是有序的，因此对map的所有操作，其实都是对红黑树的操作

·优缺点：

unordered_map：查找效率高；但是建立哈希表比较耗费时间

map：内部元素有序，查找和删除操作都是logn的时间复杂度；但是维护红黑树的存储结构需要占用一定的内存空间

·适用情况：

对于要求内部元素有序的使用map，对于要求查找效率的用unordered_map

## 7.STL中vector的实现

vector是一个动态数组，底层实现是一段连续的线性内存空间。

扩容的本质：当vector实际所占用的内存空间和容量相等时，如果再往其中添加元素需要进行扩容。其步骤如下：

·首先，申请一块更大的存储空间，一般是增加当前容量的50%或者100%，和编译器有关；

·然后，将旧内存空间的内容，按照原来的顺序放到新的空间中

·最后，将旧内存空间的内容释放掉，本质上其存储空间不会释放，只是删除了里面的内容。

从vector扩容的原理也可以看出：vector容器释放后，与其相关的指针、引用以及迭代器会失效的原因。

## 8.vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因

主要是在插入元素方面：插入元素需要考虑元素的移动问题和是否需要扩容的问题

频繁的调用push_back()也是扩容的问题对性能的影响

## 9.空间配置器

在C++中动态分配内存和释放内存分别用new和delete这两个关键字。

·new内含两阶段操作：

1.调用::operator new配置内存

2.调用Foo::Foo()构造对象的内容

·delete内含两阶段操作

1.调用Foo::~Foo()将对象析构

2.调用::operator delete释放内存

·STL allocator将以上两阶段的操作由以下几个函数来完成

内存配置：alloc:allocate()负责

内存释放：allo::deallocate()负责

对象构造：::construct()负责

对象析构：::destory()负责

内存分配与释放分别是由::operator new()和::operator delete()来完成，底层是调用malloc()和free()这两个函数来完成内存的配置和释放。

**双层级配置器：**

考虑到分配小的空间时可能会造成内存碎片问题，以及小块内存的频繁的申请和释放的性能问题，SGI STL设计了双层级配置器，默认使用第二级配置器。

·第一级配置器直接使用malloc()和free()进行内存空间的分配和释放

·第二级配置器视情况采取不同的策略：当配置区块超过128bytes时，调用第一级配置器；当配置区块小于128bytes时，采用memory pool(内存池)的方式，通过空闲链表来管理内存，第二级配置器会自动将内存的需求量上调为8的倍数，并维护16个自由链表，自由链表是一个指针数组，数组大小为16，每个数组的元素代表所挂区块的大小，free_list[0] = 8, free_list[1] = 16,以此类推（8，16，24，32，40，48，56，64，72，80，88，96，104，112，120，128）

下面详细解释下这两级配置器的流程：

参考链接：https://blog.csdn.net/lf_2016/article/details/53511648

·**一级配置器**

SGI以malloc来配置内存，配置成功直接返回

配置失败，调用内存不足处理函数oom_malloc，如果客户端没有设置内存不足的处理机制，直接抛出bad_alloc异常或者直接终止程序

如果客户端设置了内存不足的处理机制，就会一直调用这个处理机制，直到内存分配成功。这里如果内存不足的处理机制设置的不好的话，存在死循环的危险

![img](file:///C:/Users/原来是~1/AppData/Local/Temp/msohtmlclip1/01/clip_image012.jpg)

·**二级配置器**：内存池 + 空闲链表

先判断分配内存的大小，如果大于128bytes就调用一级配置器，否则通过内存池来分配，将所需内存上调至8的倍数，然后再去自由链表中相应的节点中去找，如果该节点下面挂有未使用的内存，则摘下来直接使用这部分内寸。否则调用refill(size_t n)去内存池中申请

向内存池中申请时STL默认一次申请20个，将多余的空间挂在自由链表上。refill函数中使用chunk_alloc(size_t n, size_t& nobjs)函数去内存池中申请。

如果申请成功，回到refill函数。这时，如果nobjs = 1,表明内存池只够分配一个，返回这个地址就可以；如果大于一个，需要将剩余的挂到自由链表上。

如果chunk_alloc(size_t n, size_t& nobjs)失败，

如果内存池剩余的空间足够 nobjs * n这么大，直接分配返回就OK。

如果剩余的空间leftAlloc的范围是n<=leftAlloc<=nobjs*n，就分配 nobjs = (leftAlloc) / n个空间返回就可以。

如果剩余的空间连一个n都不够，需要向heap申请内存，申请之前需要将内存池中剩余的内存挂在到自由链表上。

如果申请成功，就再调用chunk_alloc进行分配

如果失败，去看自由链表中有没有比n大的空间，如果有就将这块空间放到内存池中，再调用chunk_alloc进行分配；否则调用一级配置器，交给内存不足处理机制处理

![img](file:///C:/Users/原来是~1/AppData/Local/Temp/msohtmlclip1/01/clip_image014.jpg)

**空间配置器存在的问题：**

·自由链表所挂的区块都是8的整数倍，当我们需要非8的整数倍的区块，往往造成浪费

·配置器所有的方法和成员都是静态的，那么他们放在静态区。只有程序结束后，才释放内存，这样会导致在程序运行的过程中，自由链表一直占用内存，自己的进程可以使用，其他的进程却用不了。

 

STL面经到此就要告一段落了，分为上中下三篇，分别对面试中经常会问到的知识点进行了整理和总结，最后空间配置器了解最好，可能会在问其他问题的时候涉及到，多了解一些底层原理，有助于打开思路。

 

# 2021 秋招面经总结 —— 数据库Mysql 篇（上）

## （0）数据库的分类

![img](file:///C:/Users/原来是~1/AppData/Local/Temp/msohtmlclip1/01/clip_image016.jpg)

## （1） 关系型和非关系型数据库的区别（各自优点）

**关系型数据库**是简单的表结构，优点：易于维护，使用方便，直接用sql语句进行查询，支持复杂的多表的连接查询；缺点：读写性能差，尤其是面对海量数据的高效率读写；固定的表结构，灵活性差；高并发读写需求，面临硬盘I/O的瓶颈

**非关系型数据库**：（包括四种：键值存储数据库Redis，列存储数据库HBase，文档数据库MongoDB CoachDB，图形数据库IinforGrid）优点：格式灵活，支持以上四种格式；速度快；扩展性好；容易部署。缺点：不支持事务，不支持sql，不利于对复杂的查询

## （2） 数据库的索引类型

·唯一索引：每一个索引对应唯一的数据记录

·主键索引：以主键作为索引

·聚集索引：索引的顺序和数据存储的物理顺序是相同的

## （3） 聚集索引和非聚集索引的区别（叶节点存储内容）

·聚集索引：表数据按照索引的顺序存储，索引的顺序和表中记录的物理顺序一致。叶子节点存储了真实的数据行，不再有另外单独的数据页。（类似于新华字典中按照拼音目录（字母+声调））一张表中最多只能创建一个聚集索引，因为真实数据的物理顺序只能有一种。

·非聚集索引：索引的逻辑顺序和数据存储的物理顺序无关（类似于新华字典中的偏旁目录），叶子节点包含索引字段值及指向数据页数据行的逻辑指针，其行数量与数据表行数据量一致。

## （4） 唯一性索引和主键索引的区别

·主键索引只能创建一个，唯一索引可以创建多个

·主键索引列不能是空值，唯一索引列可以为空值

·主键索引严格来讲就是表的主键，是一种约束；唯一索引是一种索引，它是一种数据结构，二者有本质的差别

·主键索引可以作为其他表的外键，而唯一索引不可以

·主键一定会创建一个唯一索引，但有唯一索引的列不一定是主键

## （5） 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）

**索引的优缺点：**

·优点：加快表的查询速度；加快表之间的连接；唯一索引保证表中每一行数据的唯一性；在进行分组和排序查询时，减少查询中分组和排序的时间，借助索引可以提高查询的速度

·缺点：需要占额外的存储空间；索引的维护和创建需要花费一定的时间；当表发生改变时，同时也要更新索引

**什么时候需要创建索引：**

·主键自动建立唯一索引

·频繁作为查询条件的字段应该建立索引

·查询中排序字段的创建会大大提高索引速度

·查询中统计或者分组的字段

**什么时候不能使用索引：**

·频繁进行更新的字段，因为更新字段时不单单需要更新记录，还会更新索引，保存索引文件

·where条件中用不到的字段

·记录太少的表

·经常进行增删改的表

·数据重复且分布平均的字段

## （6） 索引的底层实现（B+树，为何不采用红黑树，B树）

·红黑树也可以作为索引的底层实现，但是一般不用红黑树，因为索引是以索引文件的形式存储在磁盘中，访问磁盘需要进行I/O操作，因此I/O操作的次数是衡量索引底层实现好坏的标准。

·B-树原理：树的高度为h,节点的度为d,B-树用了磁盘局部性原理，将一个节点的大小设置为一个页，这样每个节点只需要一次I/O就可以完全读入，B-树的深度决定了I/O的次数，最多进行h-1次I/O操作（根节点常驻内存）。然而红黑树的高度比B-树的高度要深的多，并且逻辑上相邻的节点在物理上可能很远，无法利用磁盘的局部性原理。因此红黑树的性能比B-树要差很多

·B+树：B+树更适合外存索引。B+树去掉了内节点去掉了data域，因此有更大的出度，有更好的性能。并且按关键字进行查找，不经过分支节点，按叶子节点的指针就能够访问所有的节点。

## （7） B树和B+树具体实现

B树和B+树都属于多路平衡查找树，是为了解决查找效率低的问题而实现的，B+树是B树的延伸

度数：在树中，每个节点的子节点（子树）的个数就称为该节点的度（degree）。

阶数：（Order）阶定义为一个节点的子节点数目的最大值。（自带最大值属性）

B树：B树的阶数为m

每个节点最多有m棵子树（最多有m-1个关键字）；所有非叶子节点除根节点外最少有m/2(取上界)棵子树（最少有m/2 - 1个关键字）。根节点至少有一个关键字

一个节点中的关键字按非降序排列

每个节点的关键字对应其子树的范围

所有的叶子节点有相同的深度（h<= logd_(n+1)/2）

B+树：B+树的阶数为m

除根节点外的内部节点，每个节点最多有m个关键字，最少有m/2个关键字，每个关键字对应一个子树；根节点要么没有子树，要么至少两棵子树

所有叶子节点包含了全部关键字，以及这些关键字指向文件的指针，所有叶子节点按关键字大小排序，相邻叶子节点顺序连接，相当于构成一个顺序链表，所有叶子节点在同一层；

分支节点中的关键字对应子树中关键字的最大值

**二者的区别：**

·B+树每个节点的关键字的个数和其子树的个数相等，而B-树关键字的个数比子树的个数少1

·B+树种所有的关键字及指针都存储到叶子节点中，内部节点相当于索引，B-树指向文件的关键字在内部节点中。

·B+树在搜索过程中，如果内部节点与当前关键字匹配，则继续搜索，直到搜索到根节点。

## （8） 索引最左前缀问题

**联合索引**：以一定顺序引用多个列，这种索引叫联合索引，一个联合索引是一个有序元组

索引的最左前缀匹配是指在建立联合索引时，索引的任何前缀都会用于查询，例如：联合索引（col1,col2,col3）这个联合索引的所有前缀就是（col1）,(col1,col2),(col1,col2,col3),包含这些列的查询都会启用索引查询；但是所有不在最左前缀里的列，即使包含在联合索引中也不会启用索引。

最左前缀匹配原则，一直向右匹配，直到遇到范围查询（>,<,between,like）就停止匹配。比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

## （9） Mysql的优化（结构优化、查询优化），MySQL慢查询优化

索引策略属于结构优化的范畴

**索引优化：**

索引优化这里不得不提到联合索引，联合索引是以一定的顺序引用多个列，在查询的过程中会使用最左前缀匹配的索引。

1.当全列匹配时，不用考虑where的查询条件中列的顺序，查询优化器会自动调整其顺序,以使用适合的索引；

2.最左前缀匹配:当匹配索引左面的一列或者几列时，会用到索引，但只会用到一部分；

3.查询条件中用到了索引中列的精确匹配中的一部分，中间某个条件未提供，如果中间这个条件对应的值少，可以考虑用IN来填补这个坑，从而形成最左前缀（隔离列的优化方式）；否则，可以建立辅助索引

4.查询条件中没有指定索引的第一列，没办法用到索引。

5.查询条件中包含匹配某列的前缀字符串，当该条件（也就是含有通配符的条件%）不出现在开头时，可以用该条件所在的列及其之前的列作为索引，查询条件不同，用到的索引的前缀的个数也不同

6.查询条件中包含范围时，包含范围的列可以作为索引，但最多只能用于一个范围列，注意BETWEEN并不代表范围，相当于关键字IN

7.查询条件中含有函数或者表达式的列，该列不会作为索引

索引的底层实现的优化：

mysql的默认的数据库引擎是innodb, innodb使用默认自增的主键作为索引，这样每次插入索引时是从右边扩展的，避免了B+树节点的频繁的分裂和合并，如果采用随机主键，会使得数据随机插入，效率低。

**为什么使用****select \* from table****会使得查询效率低？**

select * 语句取出表中所有的字段，会解析更多的对象，字段，权限，属性等，无论该字段的数据对调用的程序是否有用，这会造成服务器资源的浪费，导致优化和效率问题，对服务器的性能产生一定的影响

**总结：**

**索引方面**：为了避免全表扫描，首先考虑在where及order by涉及的列上建立索引；如果该索引是复合索引，必须使用该索引中的第一个字段作为条件时，才能用到该索引，并尽可能的让索引顺序和字段顺序一致

**Sql****语句编写方面**：在where子句中，避免对字段进行null值判断，避免使用!=,<,>操作符，避免使用or来建立连接条件，慎用in和not in ,慎用 like '%abc%'，避免对字段进行表达式操作和函数操作，会导致引擎放弃索引而进行全表扫面；用exists代替in是一个提高查询效率的方法；任何地方不要使用select * from t，用具体的字段代替“星号”，不要返回用不到的字段

**设计表时**，尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这样会降低查询和连接的效率，增加存储开销，因为引擎处理查询和连接时会逐个比较字符串中的每一个字符，对于数字型而言只比较一次就够了；尽量使用varchar代替char，因为变长字段存储空间小，可以节省内存空间，在查询时，一个较小的字段搜索效率高；避免频繁创建表、删除表，减少系统的表资源消耗。

**写在最后**

上篇重点总结了索引涉及到的知识点，这也是面试过程中的高频问题，一定要掌握的扎扎实实。

# 2021 秋招面经总结 —— 数据库Mysql 篇（中）

坚持看到中篇，已经掌握了三分之一的知识点，本篇重点总结数据库**引擎、事务、隔离性、隔离级别、连接池、表空间**等知识点。

## （10） 数据库引擎介绍，innodb和myisam的特点与区别

myISAM和innodb底层实现都是B+树，innodb是mysql默认的存储引擎

**区别：**

1.innodb支持事务并且提供了外键约束，MYISAM不支持事务并且没有外键约束

2.innodb是聚簇索引，使用B+树的索引结构，数据文件和（主键）索引文件绑在一起，因此要求表必须有主键，通过主键索引的查询效率很高，但是通过辅助索引需要查询两次，先检索辅助索引查询到主键，第二次根据主键查询到数据；主键索引的叶子节点存储的就是数据文件，辅助索引的叶子节点存储的是主键的值。因此主键不应该过大，主键太大，其他索引也都会很大；

myisam是非聚簇索引，使用B+树的索引结构，数据文件和索引文件分离，索引保存的是指向数据文件的指针，主键索引和辅助索引保存的都是数据文件的指针

**总结：**

myISAM是非聚簇索引；data域存放的是数据的地址，数据文件和索引文件在内存中是分开的，索引文件保存数据文件的地址；主索引key唯一，辅索引key可以重复

inndb是聚簇索引；data域存放的是完整的数据记录，只有数据文件；主索引key是表的主键，要求表必须有主键，根据主键创建索引，而myisam没有此要求

## （11） 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联）

事务：要做的事情，对数据库进行读写操作。事务是并发控制的基本单位，一个程序包含多个事务

A(Atomicity)C(Consistency)I(Isolation)D(Durability)==>原子性，一致性，隔离性，持久性

 

原子性：事务作为一个整体被执行，对数据的操作要么全都执行要么全不执行

一致性：事务应确保从一个一致状态转变到另一个一致状态，一致状态的含义是数据库中的数据应满足完整性约束

隔离性：多个事务并发执行时，一个事务的执行不影响其他事务的执行

持久性：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中

举例：

A向B转钱，分为六个过程：

1.读取A账户的钱；

2.A账户的钱递减；

3.写回A账户；

4.读取B账户的钱；

5.B账户的钱递增；

6.写回B账户。

 

原子性：以上转钱的中间过程要么全做，要么全部不做，中间如果某个步骤出错，则回滚（单库事务回滚使用ROLLBACK）到初始的状态，通过undo log来实现（在操作任何数据之前，首先将数据备份到undo log中，谭厚进行数据修改，如果出现了错误，执行了ROLLBACK语句，系统可以利用undo log中的备份将数据恢复到事务开始之前的状态）

一致性：A账户和B账户，转账之前和转账之后钱的总数是不变的，通过undo log来实现

隔离性：在进行并发操作时，A向B转账，C也向B转账，转账完成之后，B账户的钱是两次转账的总和；在A向B转账的过程中，只要事务还没有提交，两个账户里面的钱不会发生变化

持久性：转账成功，两个账号的钱会写入数据库中做持久化保存，通过redo log(重做日志)来实现（redo log记录的是新数据的备份，在事务提交之前只要将redo log持久化即可，不需要将数据持久化，当系统崩溃时，系统可以根据redo log的内容，将数据恢复到最新的状态）

原子性和一致性的关联：

原子性的破坏可能导致数据库的不一致，数据的不一致并不都和原子性有关。

例如：A账户向B账户转100元，但是B账户只增加了50元，此过程符合事务的原子性，但是数据的一致性被破坏了。

 

## （12） 数据库隔离性设置不同会出现的问题（丢失更新、脏读、不可重复读、幻读）

 

丢失更新：事务T1对数据进行操作，然后事务T2对相同的数据进行操作并提交，事务T1对数据进行了回滚操作，导致事务T2对数据的操作丢失；事务T1对数据进行操作，事务T2也对数据进行操作并提交，事务T1提交事务，将事务T2对数据的操作覆盖掉了。（两个事务T1、T2读入同一数据并修改，T2提交的结果破坏了T1提交的结果，导致T1的修改丢失。）

脏读：读到了数据库中未提交的数据。（读未提交）。事务T1读到了事务T2未提交的数据，并对该数据进行操作然后提交，但是事务T2对撤销了该事务，导致事务T1操作的是错误的数据。

不可重复读：一个事务T1在读取表中的数据后，另一个事务T2对表中的数据进行了修改，多次读取的结果不一样

幻读：一个事务T1读取按一定条件读取数据库中的某些数据后，另一个事务T2插入或者删除了一些记录，当T1再次读取该数据库时，出现了前后不一致的情况。（事务T1对表的全部数据进行了修改，事务T2在表里插入了一些数据，导致事务T1再次操作该表时，发现还有未修改的数据，好像出现了幻觉一样）

不可重复读和幻读的区别：

 

不可重复读：由于数据修改引起的，

幻读：由于数据插入和删除引起的，在可重复读中，sql第一次读取数据后，就将这些数据加锁，其他事物无法修改这些数据，但是可以insert数据，所以事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据，这是事务A就会发现多了一条数据，这就是幻读

## （13） 数据库的隔离级别（事务的锁），mysql和Oracle的隔离级别分别是什么

 

通过对数据库加锁实现并发控制，锁分为：排它锁（X锁，写锁）和共享锁（S锁，读锁）

 

隔离级别：四种隔离级别（读未提交、读已提交、可重复读、串行化）

 

读未提交：隔离级别最低，会引发脏读、不可重复读和幻读

读已提交：读到的都是已提交的数据，会引发不可重复读和幻读

可重复读：避免了脏读、不可重复读，会引发幻读

串行化：所有事务按照次序依次执行，脏读、不可重复读、幻读都不会出现

![img](file:///C:/Users/原来是~1/AppData/Local/Temp/msohtmlclip1/01/clip_image018.jpg)

进行读操作时，需要申请并获得S锁（共享锁，其他事务可以继续加锁，但不能加排它锁）；进行写操作时，需要申请并获得X锁（排它锁，其他事务不能再获得任何锁）

《一级封锁协议》（写操作时，加X锁，只有当X锁释放后，才能允许其他事物对该事务操作），可防止丢失修改；

《二级封锁协议》（在一级封锁协议的基础上，在读数据时加S锁，读完后释放），可防止不丢失修改，不读脏数据；

《三级封锁协议》（在一级封锁协议的基础上，读数据时加S锁，直到事务结束时释放）可防止不丢失修改，不读脏数据，不可重复读。

mysql的默认隔离级别是：可重复读。myISAM和InnoDB都支持表级锁，但Innodb默认是行级锁。

oracle支持读已提交和串行化两种隔离级别，默认情况是读已提交

## （14） 数据库连接池的作用

 

为什么会出现连接池： 在操作数据库的时候，可能会出现频繁的建立连接、关闭连接的情况。这样会大大降低系统的性能。

 

连接池： 资源池是为了解决资源频繁分配和释放所造成的问题而出现的，应用在数据库管理领域就是建立一个数据库的连接池，当需要建立连接时，调用getConnection方法获得连接；当使用完毕时，通过releaseConnection方法直接返回，并不是释放连接，只是由连接池收回，以便下一次使用。

 

作用：

 

资源复用：数据库的连接得到了重用，避免了频繁的创建连接、释放连接引起的性能开销。在减少系统消耗的基础上，也增进了系统运行环境的平稳性。

更快的响应速度：数据库连接池在初始化的过程中，往往已经建立了若干数据库连接置于池中备用。此时连接的初始化工作已经完成。对于业务请求而言，直接利用现有的可用连接，避免了数据库连接初始化和释放过程的时间，从而缩短了系统整体响应的时间。

统一的连接管理，避免了数据库连接泄漏：在较完备的数据库连接池实现中，可以根据预先的连接占用超时设定，强制收回被占用的连接。从而避免了常规数据库连接操作中可能出现的资源泄露。

## （15） Mysql的表空间方式，各自特点。

 

Mysql存储引擎是innodb,innodb的数据的存储方式有两种：共享表空间、独占表空间。（表空间是指数据库表的存储方式）

 

共享表空间：每一个数据库的所有的表数据、索引文件全部放在一个文件中，每一个表都有.frm描述文件，默认这个共享表空间的文件路径在data目录下。

独占表空间：每一个表都会以独立的文件方式来进行存储，每一个表都有.frm表描述文件，还有一个.ibd，每个表的数据和索引单独存放在以表命名的ibd文件中

共享表空间：

 

优点：表空间可以自动分成多个文件存放到各个磁盘上，一个表的数据可以分布在不同的文件上，表数据的大小限制不再是文件系统单个文件大小的限制而是InnoDB自身的限制

缺点：所有数据和索引存放到一个文件中，文件非常大，虽然可以将大文件分成多个小文件，但是整个数据库的表及索引在表空间中混合存储，这样对数据库做了大量的删除操作后，表空间会有大量的空隙

独占表空间：

 

优点：每个表都有自己独立的表空间，数据存储清晰，灾难恢复相对容易，不容易影响其他的表；可以实现单表在不同的数据库中移动；空间更容易回收；使用独占表空间的性能会高一点，无论怎么删除，表空间的碎片不会太影响性能

缺点：使用独占来存放Innodb表，每个表数据以单独的文件来存放，这时单表数据量的限制变成了文件系统大小的限制。

 

# 2021 秋招面经总结 —— 数据库Mysql 篇（下）

写在前面

 

这是面经系列数据库篇的最后一部分，涉及到分布式事务、范式、数据库中的锁、视图等知识点。

 

## （16）分布式事务

 

分布式事务：　事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点上，分布式事务是为了保证数据库的数据一致性。

 

强一致性： 任何一次都能读到某个数据的最近一次写的数据。系统中的所有进程，看到的操作顺序，都和全局时钟下的顺序一致。简言之，在任何时刻，所有节点的数据是一致的。

弱一致性： 数据更新后，能容忍后续的访问只能访问到部分或者全部访问不到。

最终一致性： 不能保证在任意时刻节点上的同一份数据都是相同的，但是随着时间的迁移，不同节点上的同一份数据总是在向趋同的方向变化。简单说，在一段时间后，节点间的数据会最终到达一致状态

CAP(Consistency, Availability, Partition torlence)原则：

 

一致性（Consistency）：在分布式系统中的所有数据备份，在同一时刻是否具有同样的值。（所有节点访问到同一份最新数据的副本）

可用性（Availability）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。

分区容错性（Partition torlence）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就有意味着发生了分区的情况，就必须在C和A之间做出选择

CAP原则：要么是AP，要么是CP，要么是CA，但是不存在CAP。

 

BASE（Base Available Soft State Eventual Consistency）理论：

BASE理论指的是基本可用Basically Available，软状态Soft State，最终一致性Eventual Consistency，核心思想：即便无法做到强一致性，但应该采用适合的方式保证最终一致性.

 

BA(Base Available)：基本可用，分布式系统在出现故障时，允许损失部分可用性，即保证核心可用

S(Soft State)：软状态，允许系统存在中间状态，而中间状态不会影响系统的可用性

E(Eventual Consistency)：最终一致性，系统中所有的副本经过一定的时间后，最终能够达到一致的状态

柔性事务： 不同于ACID的刚性事务，在分布式场景下，基于BASE理论，就出现了柔性事务的概念。要想通过柔性事务来达到最终的一致性，就需要依赖于一些特性，这些特性在具体的方案中不一定都要满足，因为不同的方案要求不一样，但是都不满足的话，是不可能做柔性事务的。

 

幂等操作： 幂等操作的特点：其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数或者幂等方程，是指可以用相同的参数重复执行，并能获得相同结果的函数。这些函数不会影响系统的状态，也不用担心重复执行会对系统造成改变。例如：支付流程中第三方支付系统告知系统中某个订单支付成功，接收该支付回掉接口在网络正常的情况下无论操作多少次都应该返回成功。

 

分布式事务使用场景：

 

转账操作：用户A使用银行app转账给用户B，银行系统首先扣掉用户A的钱，然后增加用户B账户的钱。此时会出现两种异常：1.用户A的账户扣款成功，用户B的账户余额增加失败；2.用户A账户扣款失败，用户B增加成功。此时需要用分布式事务来保证转账成功

下单扣库存：下单接口会涉及生成订单id、扣减库存等操作，对于微服务架构系统，订单id与库存服务一般都是独立的服务，此时就需要分布式事务来保证整个下单接口的成功

分布式事务的解决方案：

 

两阶段提交/XA： 分两步提交，存在一个负责协调各个本地资源管理器的事务管理器，本地资源管理器一般是由数据库实现。

流程：

事务管理器在第一阶段（prepare）的时候询问各个资源管理器是否就绪（ready状态），如果收到每个资源的回复都是yes，则在第二个阶段提交(comit)事务，如果任意一个资源的回复是no，则回滚(rollback)事务。

存在的问题：

1.同步阻塞：当事务参与者存在占用公共资源的情况，其中一个占用了资源，其他事务只能阻塞等待资源释放，处于阻塞状态；

2.单点故障：一旦事务管理器出现故障，整个系统不可用

3.数据不一致：在阶段二，如果事务管理器只发送了部分commit消息，此时网络发生异常，那么只有部分参与者接收commit消息，也就是说只有部分参与者提交了事务，使得系统数据不一致

4.不确定性：当协调本地资源管理器的事务管理器发送了commit后，并且此时只有一个参与者收到了commit，那么当该参与者与事务管理器同时宕机后，重新选举的事务管理器无法确定该条消息是否提交成功

TCC（Try-Confirm-Cancel）:

相比两阶段提交的优点：

1.同步阻塞：引入超时机制，超时后进行补偿，并且不会锁定整个资源，将资源转化为业务逻辑形式，粒度变小；

2.单点故障：解决了事务管理器出现单点故障后，整个系统不可用的问题。由主事务方发起并完成这个事务，事务管理器变成多点，引入集群；

3.数据一致性：有了补偿机制后，事务活动管理器控制一致性。

流程：

1.Try阶段：尝试执行，完成所有的业务检查（一致性），预留必须业务资源（准隔离性）。（对业务进行检查及资源预览，比如订单和存储操作，需要检查库存剩余数量是否够用，并进行预留，预留操作就是新建一个可用库存数量字段，Try阶段操作是对这个可用库存数量进行操作）

2.Confirm阶段：确认执行真正执行业务，不做任何业务检查，只使用Try阶段预留的业务资源，Confirm操作满足幂等性，Confirm操作失败后需要进行重试

3.Cancel阶段：取消执行，释放Try阶段预留的业务资源，Cancel操作满足幂等性，Cancel阶段的异常和Confirm阶段异常处理方案上基本一致

## （17） 数据库的范式

 

第一范式：属性具有原子性，不可再分解，例如：日期这个属性，如果认为日期可以分解成年月日，含有该属性的表就不是第一范式

第二范式：在第一范式的基础上，非主属性完全依赖于候选键（若干主属性组成），不存在部分依赖

第三范式：在满足第二范式的基础上，消除传递依赖，就是说每个非主属性都不传递依赖于候选码。例如：（学生，课程，老师，老师职称），（学生，课程）->老师->老师职称，老师和老师职称这里存在传递依赖。

BC范式：在满足第三范式的基础上主属性不依赖于主属性

## （18） 数据的锁的种类，加锁的方式

 

按照锁的粒度进行划分：行锁、表锁、页锁

 

行锁：加锁的粒度最小

表锁：加锁的粒度最大

页锁：粒度介于行锁和表锁之间

按照使用方式进行划分：排它锁、共享锁

排它锁（X锁，写锁）：事务对数据对象加上X锁，既可以对数据进行读操作，又可以对数据进行写操作；但其他事务不能对A加任何锁

共享锁（S锁，读锁）：事务T对数据加上S锁，只能对数据进行读操作，其他事务只能对数据加S锁，不能加X锁，直到事务T释放S锁。

两种思想上的锁：悲观锁和乐观锁

## （19） 视图的作用与使用方法（如何删除等）

 

视图：从一个表或几个基本表导出的表，与基本表不同，它是一个虚表，数据库中只存放视图的定义而不存放视图对应的数据，这些数据存依然放在基本表中。

视图的使用方法：

 

建立视图：create view <视图名>[列名1， 列名2，……] as <子查询> [with check option]. with check option表示对视图进行增、删、改操作时，保证增删改的行满足视图中子查询中的条件表达式。

删除视图：drop view <视图名>[cascsde]，视图删除后视图的定义将从数据字典中删除，使用cascade级联删除语句把该视图和由他导出的所有视图一起删除。注意：基本表删除，并不意味着由该基本表定义的视图一起删除，视图依然在数据字典中，删除视图需要显示的使用drop view语句。

查询视图：查询视图的操作和查询表的操作，sql语句的写法是一样的。只不过在对视图进行查询时，会将该查询语句与视图的子查询结合起来，转化为等价的对基本表的查询，这个转化过程称为视图消解。

更新视图：由于视图中存放的不是实际的存储数据，因此对视图的更新转化为对基本表的更新。但是并不是所有的视图都是可更新的

视图能够简化用户的操作：使用户将注意力集中在所关心的数据上

使用户从多角度看待同一数据

对重构数据提供了一定程度的逻辑独立性：数据具有逻辑独立性（当数据重构造时，如增加新的关系或对原有的关系增加新的字段等，用户的应用程序不受影响）和物理独立性（用户的应用程序不依赖于数据库的物理结构）

对机密数据提供安全保护

适当利用视图可以清晰表达查询

## （20） 分库分表，主从复制，读写分离。

 

技术出现的背景：随着数据库中的数据量越来越大，查询所需的时间就会越来越长；另外MySQL会对更改表的数据加锁，会阻塞其他的操作。

从以上两个方面进行考虑，数据量大的问题采用分库分表解决；对于写操作会阻塞后续的读操作，采用读写分离解决。

分表：

 

水平划分：按照行级进行划分，同一模块下多个结构相同的子表

垂直划分：按照列进行划分，将表划分为不同字段结构的表

分库：

 

水平划分：主要根据数据属性（例如：商品所属地市，种类）拆分物理数据库，从而解决数量过大IO密集问题；

垂直划分：按照业务模块划分出不同的数据库，而不是将所有的表都存放在同一个数据库中。例如：商场订单模块放在主机1中的数据库，商品模块放在主机2中的订单

读写分离：在主服务器上修改，数据会同步到从服务器，从服务器只能提供读数据，不能提供写入，实现备份的同时也实现了数据库性能的优化，以及提升了服务器的安全性。

 

## （21）order by的底层原理：

 

rowid排序： 将待排序的字段放在sort_buffer中进行排序，然后根据该字段在查询其对应其他列的字段

全字段排序： 将所要取出的字段放在sort_buffer中进行排序，排好序保存结果

## （22） 项目中哪里用到了数据库，怎么用的

结合项目来回答，笔者面试过程中被问道数据库中设计了哪些表，然后针对这些表考察 sql 语句的编写。