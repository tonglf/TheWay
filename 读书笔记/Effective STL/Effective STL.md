# Effective STL

## 50 条有效使用 STL 的经验

# 容器

## 1、慎重选择容器类型

**容器类型：**

> **序列容器：vector、string、deque、list、forward_list、array**
>
> **关联容器：set、multiset、map、multimap、unordered_set、unordered_map、unordered_multiset、unordered_multimap**
>
> **容器适配器：stack、queue、priority_queue**

**如何在 vector、deque 和 list 中做出选择？**

> vector、list 和 deque 为程序员提供了不同的复杂性， 使用时要对此做出权衡。
>
> vector 是默认应使用的序列类型；
>
> 当需要频繁地在序列中间 做插入和删除操作时，应使用 list;
>
> 当大多数插入和删除操作发生在序列的头部和尾部时，deque 是应考虑的数据结构。

**选择容器时最终要的一些问题**

- **你是否需要在容器的任意位置插入新元素？**

  ​	如果需要，就选择序列容器；关联容器是不行的。

- **你是否关心容器中的元素是如何排序的？**

  ​	如果不关心， 则哈希容器是一个可行的选择方案；否则，你要避免哈希容器。

- **你需要哪种类型的迭代器？**

  ​	如果它们必须是随机访问迭代器， 则对容器的选择就被限定为 vector、deque 和 string。如果要求使用双向迭代器， 那么你必须避免 forward_list (见第 50 条）以及哈希容器的一个常见实现（见第25条）。

- **当发生元素的插入或删除操作时， 避免移动容器中原来的元素是否很重要？**

  ​	如果是，就要避免连续内存的容器（见第5 条）。

- **容器中数据的布局是否需要和 C 兼容？**

  ​	如果需要兼容， 就只能选择 vector（见第 16 条）。

- **元素的查找速度是否是关键的考虑因素？**

  ​	如果是，就要考虑哈希容器（见第25条）、 排序的 vector (见第 23 条）和标准关联容器一一或许这就是优先顺序。

- **如果容器内部使用了引用计数技术(reference counting), 你是否介意？**

  ​	如果是， 就要避免使用 string，因为许多 string 的实现都使用了引用计数。当然，你需要某种表示字符串的方法，这时你可以考虑 vector\<char>。

- **对插入和删除操作，你需要事务语义 (transactional semantics) 吗？也就是说，在插入和删除操作失败时，你需要回滚的能力吗？**

  ​	如果需要，你就要使用基于节点的容器。如果对多个元素的插入操作（即针对一个区间的形式——见第 5 条）需要事务语义， 则你需要选择 list, 因为在标准容器中， 只有 list 对多个元素的插入操作提供了事务语义。对那些希望编写异常安全 (exception-safe)代码的程序员，事务语义显得尤为重要。（使用连续内存的容器也可以获得事务语义， 但是要付出性能上的代价， 而且代码也显得不那么直截了当。 更多细节，请参考 Sutter 的 Exceptional C++[8] 中的第 17 条。）

- **你需要使迭代器、指针和引用变为无效的次数最少吗？**

  ​	如果是这样， 就要使用基于节点的容器， 因为对这类容器的插入和删除操作从来不会使迭代器、 指针和引用变为无效（除非它们指向了一个你正在删除的元素）。 而针对连续内存容器的插入和删除操作一般会使指向该容器的迭代器、 指针和引用变为无效。

- **如果序列容器的迭代器是随机访问类型， 而且只要没有删除操作发生， 且插入操作只发生在容器的末尾， 则指向数据的指针和引用就不会变为无效， 这样的容器是否对你有帮助？**

  ​	这是非常特殊的情形， 但如果你面对的情形正是如此， 则 deque 是你所希望的容器。（有意思的是， 当插入操作仅在容器末尾发生时， deque 的迭代器有可能会变为无效。deque 是惟—的、 迭代器可能会变为无效而指针和引用不会变为无效的 STL 标准容器）。

## 2、不要试图编写独立于容器类型的代码



# vector 和 string



# 关联容器



# 迭代器



# 算法



# 函数子、函数子类、函数及其他



# 在程序中使用 STL