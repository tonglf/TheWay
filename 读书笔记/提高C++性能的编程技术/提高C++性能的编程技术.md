# 提高C++性能的编程技术

# 跟踪实例

**要点：**

- **对象定义会触发隐形执行构造函数和析构函数。**我们称其为“隐形执行”而不是“隐形开销”，是因为对象的构造和销毁并不总是意味着产生开销。如果构造函数和析构函数所执行的计算是必须的，那么就要考虑使用高效的代码（内联会减少函数调用和返回的开销）。就像我们所看到的那样，构造函数和析构函数并不是总是具有如此 “完美的“ 特性， 而且它们能够产生可观的开销。某些情况下，构造函数（或析构函数） 所执行的计算是无用的。我们还应当指出， 这个问题不止是一个 C++ 语言编程的问题，更是一个设计问题。 不过，因为 C 不支持构造函数和析构函数， 所以这种现象在 C 中比较少见。

- 正是因为通过引用传递对象还是不能保证良好的性能，所以避免对象的复制的确有利于提高性能，但是如果我们不必一开始就创建和销毁该对象的话，这种处理方式将更有利于性能的提升。
- **不要把精力浪费在计算结果根本不会被使用的地方。**当关闭跟踪时，string 成员的创建就是一种无用而高代价的开销。
- **别打算创造设计灵活性的世界纪录。**您的设计只需要在当前问题范围之内足够灵活就可以了。在完成同样的简单工作时，char 指针有时可以比 string 对象更有效率。
- **内联消除了常被使用的小函数调用所产生的函数开销。** 内联 Trace 的构造函数和析构函数使得消除 Trace 的开销变得更加容易。



# 构造函数和析构函数

**要点：**

- 构造函数和析构函数可以像手工编写的 C 代码一样有效。然而在实践中，它们经常包含冗余计算。
- **对象的创建（或销毁）触发对父对象和成员对象的递归创建（或销毁）**。要当心复杂层次中对象的复合使用。 它们使得创建和销毁的开销更为高昂。
- **要确保所编写的代码实际使用了所有创建的对象和这些对象所执行的计算。**我们鼓励程序员深入研究他们所使用的类。这个建议不会受到面向对象程序设计提倡者的欢迎，毕竟面向对象的程序设计劝诫将类作为黑盒使用，不鼓励人们窥探其内部结构。怎样平衡这两条相互对立的建议呢？这个问题没有简单的答案， 因为它与所处的环境有关。尽管黑盒方法对千80%的代码都能表现得十分完美， 但它却可能对另外20%性能要求苛刻的代码造成很大 的伤害。它也是与应用程序相关的。有的应用程序注重可维护性和灵活性， 而另一些应用程序则可能把对性能的考虑放在最为重要的位置。 作为程序员， 应当清楚自已到底更看重哪个方面。
- 对象的生命周期不是无偿的。至少对象的创建和销毁会消耗 CPU 周期。不要随意创建一个对象，除非你打算使用它。通常情况下，**要等到需要使用对象的地方再创建它**。
- **编译器必须初始化被包含的成员对象之后再执行构造函数体。您必须在初始化阶段完成成员对象的创建。这可以降低随后在构造函数部分调用赋值操作符的开销。在某些情况下，这样也可以避免临时对象的产生。**



# 虚函数

**要点：**

- **虚函数的代价在于无法内联函数调用， 因为这些调用是在运行时动态绑定的。 唯一潜在的效率问题是从内联获得的速度（如果可以内联的话）。 但对于那些代价并非取决于调用和返回开销的函数来说， 内联效率不是问题。**
- **模板比继承提供更好的性能。它把对类型的解析提前到编译期间，我们认为这是没有成本的。**



# 返回值优化

**要点：**

- 如果必须按值返回对象，通过 RVO 可以省去创建和销毁局部对象的步骤，从而改善性能。
- RVO 的应用要遵照编译器的实现而定。这需要参考编译器文档或通过实验来判断是否使用 RVO 以及何时使用。
- 通过编写计算性构造函数可以更好地使用 RVO。

返回值优化（Return Value Optimization，RVO）



# 临时对象

**要点：**

- 临时对象会以构造函数和析构函数的形式降低一半的性能。
- 将构造函数声明为 **explicit**，可以阻止编译器在幕后使用类型转换。
- 编译器常常创建临时对象来解决**类型不匹配**问题。通过函数重载可以避免这种情况。
- 如果可能，应尽量避免使用对象拷贝。**按引用传递和返回对象**。
- 在 \<op> 可能是 “+、-、*” 或者 “/” 的地方，**使用 \<op>= 运算符可以消除临时对象**。



# 单线程内存池

**要点：**

- 灵活性以速度的降低为代价。随着内存管理的功能和灵活性的增强，执行速度将降低。

- 全局内存管理器（由 new() 和 delete() 执行）是通用的， 因此代价高。

- 专用内存管理器比全局内存管理器快一个数量级以上。
- 如果主要分配固定大小的内存块，专用的固定大小内存管理器将明显地提升性能。
- 如果主要分配限于单线程的内存块， 那么内存管理器也会有类似的性能提高。 由于省去了全局函数 new() 和 delete() 必须处理的并发问题， 单线程内存管理器的性能有所提高。



# 多线程内存池

**要点：**

- 全局内存管理器（通过 new() 和 delete() 实现） 是通用的， 因此它的开销也非常大。

- 因为单线程内存管理器要比多线程内存管理器快得多，所以如果要分配的大多数内存块限于单线程中使用， 那么可以显著提升性能。
- 如果开发了一套有效的单线程分配器，那么通过模板可以方便地将它们扩展到多线程环境中。



# 内联基础

**要点：**





# 内联——站在性能的角度

**要点：**





# 内联技巧

**要点：**





# 标准模板库

**要点：**





# 引用计数

**要点：**





# 编码优化

**要点：**





# 设计优化

**要点：**





# 可扩展性

**要点：**





# 系统体系结构相关话题

**要点：**





