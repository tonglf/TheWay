# 提高C++性能的编程技术

# 跟踪实例

**要点：**

- **对象定义会触发隐形执行构造函数和析构函数。**我们称其为“隐形执行”而不是“隐形开销”，是因为对象的构造和销毁并不总是意味着产生开销。如果构造函数和析构函数所执行的计算是必须的，那么就要考虑使用高效的代码（内联会减少函数调用和返回的开销）。就像我们所看到的那样，构造函数和析构函数并不是总是具有如此 “完美的“ 特性， 而且它们能够产生可观的开销。某些情况下，构造函数（或析构函数） 所执行的计算是无用的。我们还应当指出， 这个问题不止是一个 C++ 语言编程的问题，更是一个设计问题。 不过，因为 C 不支持构造函数和析构函数， 所以这种现象在 C 中比较少见。

- 正是因为通过引用传递对象还是不能保证良好的性能，所以避免对象的复制的确有利于提高性能，但是如果我们不必一开始就创建和销毁该对象的话，这种处理方式将更有利于性能的提升。
- **不要把精力浪费在计算结果根本不会被使用的地方。**当关闭跟踪时，string 成员的创建就是一种无用而高代价的开销。
- **别打算创造设计灵活性的世界纪录。**您的设计只需要在当前问题范围之内足够灵活就可以了。在完成同样的简单工作时，char 指针有时可以比 string 对象更有效率。
- **内联消除了常被使用的小函数调用所产生的函数开销。** 内联 Trace 的构造函数和析构函数使得消除 Trace 的开销变得更加容易。



# 构造函数和析构函数

**要点：**

- 构造函数和析构函数可以像手工编写的 C 代码一样有效。然而在实践中，它们经常包含冗余计算。
- 对象的创建（或销毁）触发对父对象和成员对象的递归创建（或销毁）。要当心复杂层次中对象的复合使用。 它们使得创建和销毁的开销更为高昂。
- 要确保所编写的代码实际使用了所有创建的对象和这些对象所执行的计算。我们鼓励程序员深入研究他们所使用的类。这个建议不会受到面向对象程序设计提倡者的欢迎，毕竟面向对象的程序设计劝诫将类作为黑盒使用，不鼓励人们窥探其内部结构。怎样平衡这两条相互对立的建议呢？这个问题没有简单的答案， 因为它与所处的环境有关。尽管黑盒方法对千80%的代码都能表现得十分完美， 但它却可能对另外20%性能要求苛刻的代码造成很大 的伤害。它也是与应用程序相关的。有的应用程序注重可维护性和灵活性， 而另一些应用程序则可能把对性能的考虑放在最为重要的位置。 作为程序员， 应当清楚自已到底更看重哪个方面。
- 对象的生命周期不是无偿的。至少对象的创建和销毁会消耗 CPU 周期。不要随意创建一个对象，除非你打算使用它。通常情况下，要等到需要使用对象的地方再创建它。
- 编译器必须初始化被包含的成员对象之后再执行构造函数体。您必须在初始化阶段完成成员对象的创建。这可以降低随后在构造函数部分调用赋值操作符的开销。在某些情况下，这样也可以避免临时对象的产生。



# 虚函数





# 返回值优化

