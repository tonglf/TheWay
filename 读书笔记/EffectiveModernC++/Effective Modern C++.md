# Effective Modern C++

# 第一章 型别推导

## 1、理解模板型别推导

**要点速记：**

- 在模板推导的过程中，具有引用型别的的实参会被当成非引用型别来处理。换言之，其引用性会被忽略。
- 对万能引用形参进行推导时，左值实参会进行特殊处理。
- 对按值传递的形参进行推导时，若实参型别中带有 const 或 volatile 饰词，则它们还是会被当作不带 const 或 volatile 饰词的型别来处理。
- 在模板型别推导的过程中，数组或函数型别的实参会退化成对应的指针，除非它们被用来初始化引用。



## 2、理解 auto 型别推导

**要点速记：**

- 在一般情况下，auto 型别推导和模板型别推导是一模一样的，但是 auto 型别推导会假定用大括号括起的初始化表达式代表一个 `std::initializer_list`，但模板型别推导却不会。
- 在函数返回值或 lambda 式中的形参中使用 auto，意思是使用模板型别推导而非 auto 型别推导。



## 3、理解 decltype

**要点速记：**

- 绝大多数情况，decltype 会得出变量或表达式的型别而不作任何修改。
- 对于型别 T 的左值表达式，除非该表达式仅有一个名字，decltype 总是得出型别 T&。
- C++ 14 支持 decltype(auto)，和 auto 一样，它会从其初始化表达式出发来推导型别，但是它的型别推导使用的是 decltype 的规则。

## 4、掌握查看型别推导结果的方法

**要点速记：**

- 利用 IDE 编辑器、编辑器错误消息和 Boost.TypeIndex 库常常能够查看到推导而获得型别。
- 有些工具产生的结果可能会无用，或者不准确。所以，理解 C++ 型别推导规则是必要的。



# 第二章 auto

## 5、优先选用 auto，而非显示型别声明

**要点速记：**

- auto 变量必须初始化，基本上对会导致兼容性和效率问题的型别不匹配现象免疫，还可以简化重构流程，通常也比显式指定型别要少打一些字。
- auto 型别变量都有着条款 2 和条款 6 中所描述的毛病。



## 6、当 auto 推导的型别不符合要求时，使用带显式型别的初始化物习惯用法

**要点速记：**

- ”隐形“ 的代理型别可以导致 auto 根据初始化表达式推导出的 ”错误的“ 型别。
- 带显式型别的初始化物习惯用法强制 auto 推导出你想要的型别。



# 第三章 转向现代 C++

## 7、在创建对象时注意区分 () 和 {}

**要点速记：**

- 大括号初始化可以应用的语境最为宽泛，可以阻止隐式窄化型别转换，还对最令人苦恼之解析语法免疫。
- 在构造函数重载决议期间，只要有任何可能，大括号初始化物就会与带有 `std::initializer_list` 型别的形参相匹配，即使其他重载版本有着貌似更加匹配的形参表。
- 使用小括号还是大括号，会造成结果大相径庭的一个例子是：使用两个实参来创建一个 `std::vector<数值类型>` 对象。
- 在模板内容进行对象创建时，到底该使用小括号还是大括号会成为一个棘手的问题。



## 8、优先选用 nullptr，而非 0 或 NULL

**要点速记：**

- 相对于 0 和 NULL，优先使用 nullptr。
- 避免在整型和指针型别之间重载。



## 9、优先选用别名声明，而非 typedef

**要点速记：**

- `typedef` 不支持模板化，但别名声明支持。
- 别名模板可以让人免写 “ `::type` “ 后缀，并且在模板内，对于内嵌 `typedef` 的引用经常要求加上 `typename` 前缀。



## 10、优先选用限定作用域的枚举类型别，而非不限作用域的枚举型别

**要点速记：**

- C++ 98 风格的枚举型别，现在称为不限范围的枚举型别。
- 限定作用域的枚举型别仅在枚举型别内可见。它们只能通过强制型别转换以转换至其他型别。
- 限定作用域的枚举型别和不限范围的枚举型别都支持底层型别指定。限定作用域的枚举型别默认底层型别是 `int`，而不限范围的枚举型别没有默认底层型别。
- 限定作用域的枚举型别总是可以进行前置声明，而不限范围的枚举类型却只有在指定了默认底层型别的前提下才可以进行前置声明。



## 11、优先选用删除函数，而非 private 未定义函数

**要点速记：**

- 优先选用删除函数（`= delete`），而非 private 未定义函数。
- 任何函数都可以删除，包括非成员函数和模板具现。



## 12、为意在改写的函数添加 override 声明

**要点速记：**

- 为意在改写的函数添加 override 声明。
- 成员函数引用饰词使得对于左值和右值对象（ *this ）的处理能够区分开来。



## 13、优先选用 const_iterator，而非 iterator

**要点速记：**

- 优先选用 const_iterator，而非 iterator。
- 在最通用的代码中，优先选用非成员函数版本的 begin、end 和 rbegin等，而非其成员版本函数。



## 14、只要函数不会发射异常，就为其加上 noexcept 声明

**要点速记：**

- noexcept 声明是函数接口的组成部分，这意味着调用方可能会对它有依赖。

- 相对于不带 noexcept 声明的函数，带有 noexcept 声明的函数有更多机会得到优化。
- noexcept 性质对于移动操作、swap、内存释放函数和析构函数最有价值。
- 大多数函数都是异常中立的，不具备 noexcept 性质。



## 15、只要有可能使用 constexpr，就使用它

**要点速记：**

- constexpr 对象都具备 const 属性，并由编译期已知的值完成初始化。
- constexpr 函数在调用时若传入的实参值是编译器已知的，则会产出编译期结果。
- 比起非 constexpr 对象或 constexpr 函数而言，constexpr 对象或是 constexpr 函数可以在一个作用域更广的语境中。



## 16、保证 const 成员函数的线程安全性

**要点速记：**

- 保证 const 成员函数的线程安全性，除非可以确信它们不会用在并在语境中。
- 运用 std::atomic 型别的变量会比运用互斥量提供更好的性能，但前者仅适用对单个变量或内存区域的操作。



## 17、理解特种成员函数的生成机制

**要点速记：**

- 特种成员函数是指那些 C++　会自动生成的成员函数：默认构造函数、析构函数、复制函数（拷贝构造函数、赋值运算符），以及移动操作（移动构造函数、移动运算符 —— C++ 新加入的两个函数）。
- 移动操作仅当类中未包含用户显式声明的复制操作、移动操作和析构函数是才生成。
- 复制构造函数仅当类中不包含用户显式声明的复制构造函数时才生成，如果该类声明了移动操作则复制构造函数将被删除，复制赋值运算符仅当类中不包含用户显式声明的复制赋值运算符才生成，如果该类声明了移动操作则复制赋值运算符将被删除。在已经存在显式声明的析构函数的条件下，生成复制操作已经成为了被废弃的行为。
- 成员函数模板在任何情况下都不会抑制特种成员函数的生成。



# 第四章 智能指针

## 18、使用 std::unique_ptr 管理具备专属所有权的资源

**要点速记：**

- std::unique_ptr 是小巧、高速的、具备只移型别的指针，对托管资源实施专属所有权语义。
- 默认地，资源析构采用 delete 运算符实现，但可以指定自定义删除器。有状态的删除器和采用函数指针实现的删除器会增加 std::unique_ptr 型别的对象尺寸。
- 将 std::unique_ptr  转化成 std::shared_ptr 是容易实现的。



## 19、使用 std::shared_ptr 管理具备共享所有权的资源

**要点速记：**

- std::shared_ptr 提供方便的手段，实现了任意资源在共享所有权语义下进行生命周期管理的垃圾回收。
- 与 std::unique_ptr 相比，std::shared_ptr 的尺寸通常是裸指针尺寸的两倍，它还会带来控制块的开销，并要求原子化的引用计数操作。
- 默认的资源析构通过 delete 运算符进行，但同时也支持定制删除器。删除器的型别对 std::shared_ptr 的型别没有影响。
- 避免使用裸指针型别的变量来创建 std::shared_ptr 指针。



## 20、对于类似 std::shared_ptr 但有可能空悬的指针使用 std::weak_ptr 

**要点速记：**

- 使用 std::weak_ptr 来代替可能空悬的 std::shared_ptr。
- std::weak_ptr 可能的用武之地包括缓存，观察者列表，以及避免 std::shared_ptr 指针环路。



## 21、优先使用 std::make_unique 和 std::make_shared，而非直接使用 new

**要点速记：**

- 相比于直接使用 new 表达式，make 系列函数消除了重复代码、改进了异常安全性，并且对于 std::make_shared 和 std::allcoated_shared 而言，生成的目标代码会尺寸更小、速度更快。
- 不适于使用 make系列的场景包含需要定制删除器，以及期望直接传递大括号初始化物。
- 对于  std::shared_ptr，不建议使用 make 系列函数的额外场景包括：
  1. 自定义内存管理的类；
  2. 内存紧张的系统、非常大的对象、以及存在比指涉到相同对象的 std::shared_ptr 生存周期更久的 std::weak_ptr。



## 22、使用 Pimpl 习惯用法时，将特殊成员函数的定义放到实现文件中去

**要点速记：**

- Pimpl 惯用法通过降低类的客户和实现者之间的依赖性，减少了构建遍数。
- 对于采用 std::unique_ptr 来实现的 pImpl 指针，须在类的头文件中声明特种成员函数，但在实现文件中实现它们。即使默认函数实现有着正确行为，也必须这样做。
- 上述建议仅适用于 std::unique_ptr，但不适用于 std::shared_ptr。



# 第五章 右值引用、移动语义和完美转发

## 23、

**要点速记：**



## 24、

**要点速记：**



## 25、

**要点速记：**



## 26、

**要点速记：**



## 27、

**要点速记：**



## 28、

**要点速记：**



## 29、

**要点速记：**



## 30、

**要点速记：**



# 第六章 lambda 表达式

## 31、避免默认捕获方式

**要点速记：**

- 按引用的默认捕获方式会导致悬空指针问题。
- 按值的默认捕获极易受空悬指针影响（尤其是 this ），并会误导人们认为 lambda 是自洽的。



## 32、使用初始化捕获将对象移入闭包

**要点速记：**

- 使用 C++ 14 的初始化捕获将对象移入闭包。
- 在 C++ 11 中，经由手工实现的类或 std::bind 去模拟初始化捕获。



## 33、对 auto&& 型别的形参使用 decltype，以 std::forward 之

**要点速记：**

- 对 auto&& 型别的形参使用 decltype，以 std::forward 之



## 34、优先选用 lambda 式，而非 std::bind

**要点速记：**

- lambda 式比起使用 std::bind 而言，可读性更好、表达式更强，可能运行效率也更高。
- 仅在 C++ 11 中，std::bind 在实现移动捕获，或是绑定到具备模板化的函数调用运算符的对象场合中，可能尚有余热可以发挥。



# 第七章 并发 API



# 第八章 微调

## 41、针对可复制的形参，在移动成本低并且一定会被复制的情况下，考虑将其按值传递

**要点速记：**

- 对于可复制的、在移动成本低廉的并且一定会被复制的形参而言，按值传递可能会和按引用传递的具备相近的效率，并可能生成更少量的目标代码。
- 经由构造复制形参的成本可能比经由赋值赋值形参高出很多。
- 按值传递肯定会导致切片问题，所以基类型别特别不适用于按值传递。



## 42、考虑置入而非插入

**要点速记：**

- 从原理上说，置入函数应该有时比对应的插入函数高效，而且不应该有更低效的可能。
- 从实践上说，置入函数在以下几个前提成立时，极有可能会运行得更快：
  - 待添加的值是以构造而非赋值方式加入容器
  - 传递的实参型别与容器持有之物的型别不同
  - 容器不会由于存在重复值而拒绝待添加的值
- 置入函数可能会执行在插入函数中会被拒绝的型别转换。
