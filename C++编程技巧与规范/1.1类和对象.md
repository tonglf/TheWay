# 类和对象

## 第一节 静态对象的探讨与全局对象的构造顺序

### 静态对象的探讨

#### 类中的静态成员变量【类类型静态成员】

```cpp
#include <iostream>
using namespace std;

class A {
public:
	A()	{
		cout << "A的构造函数" << endl;
	}
    
	~A() {
		cout << "A的析构函数" << endl;
	}
};

class B {
public:
	B() {
		cout << "B的构造函数" << endl;
	}
    
	~B() {
		cout << "B的析构函数" << endl;
	}
public:
	static A a;		// 静态成员变量声明		可以写成 inline static A a; 这样下面的定义就不用写了
};

A B::a;		// 静态成员变量定义

int main()		// main函数中无任何代码
{

}
// 输出：
// A的构造函数
// A的析构函数 
```

> 类中的静态类型成员变量，即使没有被使用，也会被构造和析构。
>
> C++17中引入“ inline 静态成员变量 ”，即表示静态成员变量在类内声明和定义。

#### 函数中的静态对象 【类类型静态对象】

```c++
#include <iostream>
using namespace std;

class A
{
public:
	A()
	{
		cout << "A的构造函数" << endl;
	}
	~A()
	{
		cout << "A的析构函数" << endl;
	}
};

void func()
{
	static A a;
}

int main()
{
	func();		// 调用多次函数
	func();
	func();
}
// 输出：
// A的构造函数
// A的析构函数
```

> 如果 func 函数没有被调用过，那么这个静态对象就不会被构造。
>
> 即使这个函数被调用多次，该静态对象也只会被构造一次。

### 全局对象的构造顺序问题

**全局对象的构造顺序是不确定的**

如果一个项目中有多个 .cpp 文件，每个源文件中都可能定义这一些不同的全局对象，那么这些全局对象的构造顺序（初始化顺序）是无规律的。

千万不要：构造一个全局对象的时候，需要用到另外一个全局对象，因为根本无法确定另外一个全局对象是否已经被构造出来。

