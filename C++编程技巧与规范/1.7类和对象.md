# 类和对象

## 第七节 虚析构函数的内存泄漏问题深谈

有以下两个类，其中 B 类继承 A 类。

```cpp
class A {
public:
	A() {}
	~A() {
		std::cout << "A 的析构函数" << std::endl;
	}
};

class B : public A {
public:
	B()
	{
		m_pb = new int(4);
	}
	~B() {
		delete m_pb;
		std::cout << "B 的析构函数" << std::endl;
	}
	int* m_pb;
};

int main()
{
	A* a2b = new B;	// 父类指针指向子类对象
	delete a2b;
}					// 输出：A 的析构函数
```

上述代码中，删除对象 a2b 并未调用 B 的析构函数，而是调用了 A 的析构函数，这就造成了内存泄漏。

处理方式就是将 A 类中的析构函数设为虚析构函数。如下：

```cpp
class A {
public:
	A() {}
	virtual ~A() {				// 设为虚函数
		std::cout << "A的析构函数" << std::endl;
	}
};

// 输出：
//	B 的析构函数
//		A 的析构函数
```

加入了虚函数后，析构函数就会调用子类的析构函数，避免了内存泄漏。注意到，==子类和父类的析构函数都没调用了==，顺序为先子后父。

**总结：**

- 若一个类不打算被继承，那么析构函数不用设置为虚函数，若设置了虚函数，会给类建立一个虚函数表，增加开销。

- 若一个类被 public 继承，并想实现多态的功能，一定要把父类的析构函数设为虚函数，否则会造成内存泄漏。

