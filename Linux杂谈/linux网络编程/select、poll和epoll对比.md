# select 、poll 和 epoll 对比

## select /poll 的性能问题

**select /poll 的性能会随着监控的文件描述符数量增多而快速下降。**其原因是多方面的。

其中一个原因是**它们所监控的文件描述符会以某种数据结构全部传送给内核，让内核负责监控这些文件描述符，当内核发现某个文件描述符已经就绪时，会修改数据结构，然后将修改后的数据结构传回给进程**。所以涉及了两次数据传输的过程。

对于 select() 来说，每次传递的数据结构的大小是固定的，都是 1024 个描述符的大小。对于 poll() 来说，只会传递被监控的文件描述符，所以文件描述符少的时候，poll() 的性能是可以的，此外 poll() 可以超出 1024 个文件描述符的监控数量限制，但随着描述符数量的增多，来回传递的数据量也是非常大的。

基于这方面的性能考虑，更建议使用信号驱动 IO 或 epoll 模型，**它们都是直接告诉内核要监控哪些文件描述符，内核会以合适的数据结构安排这些待监控的文件描述符 (如 epoll，内核采用红黑树的方式)，换句话说，它们不会传递一大片的文件描述符数据结构，效率更高。**

## select 、poll 和 epoll

前面说了，这三个函数是文件描述符状态监控的函数，它们可以监控一系列文件的一系列事件，当出现满足条件的事件后，就认为是就绪或者错误。事件大致分为 3 类：可读事件、可写事件和异常事件。它们通常都放在循环结构中进行循环监控。

select() 和 poll() 函数处理方式的本质类似，只不过 poll() 稍微先进一点，而 epoll 处理方式就比这两个函数先进多了。当然，就算是先进分子，在某些情况下性能也不一定就比老家伙们强。

### select & poll 

首先，通过 FD_SET 宏函数创建待监控的描述符集合，并将此描述符集合作为 select() 函数的参数，可以在指定 select() 函数阻塞时间间隔，于是 select() 就创建了一个监控对象。

除了普通文件描述符，还可以监控套接字，因为套接字也是文件，所以 select() 也可以监控套接字文件描述符，例如 recv buffer 中是否收到了数据，也即监控套接字的可读性，send buffer 中是否满了，也即监控套接字的可写性。select() 默认最大可监控 1024 个文件描述符。而 poll() 则没有此限制。

select() 的时间间隔参数分3种：

- 设置为指定时间间隔内阻塞，除非之前有就绪事件发生。
- 设置为永久阻塞，除非有就绪事件发生。
- 设置为完全不阻塞，即立即返回。但因为 select() 通常在循环结构中，所以这是轮询监控的方式。

当创建了监控对象后，由内核监控这些描述符集合，于此同时调用 select() 的进程被阻塞(或轮询)。当监控到满足就绪条件时(监控事件发生)，select() 将被唤醒(或暂停轮询)，于是 select() 返回**满足就绪条件的描述符数量**，之所以是数量而不仅仅是一个，是因为多个文件描述符可能在同一时间满足就绪条件。由于只是返回数量，并没有返回哪一个或哪几个文件描述符，所以通常在使用select()之后，还会在循环结构中的if语句中使用宏函数FD_ISSET进行遍历，直到找出所有的满足就绪条件的描述符。最后将描述符集合通过指定函数拷贝回用户空间，以便被进程处理。

监听描述符集合的大致过程如下图所示，其中 select() 只是其中的一个环节：

![图片](.\Image\select 、poll 和 epoll 对比.jpg)

大概描述下这个循环监控的过程：

(1).首先通过FD_ZERO宏函数初始化描述符集合。图中每个小方格表示一个文件描述符。
(2).通过FD_SET宏函数创建描述符集合，此时集合中的文件描述符都被打开，也就是稍后要被select()监控的对象。
(3).使用select()函数监控描述符集合。当某个文件描述符满足就绪条件时，select()函数返回集合中满足条件的数量。图中标黄色的小方块表示满足就绪条件的描述符。
(4).通过FD_ISSET宏函数遍历整个描述符集合，并将满足就绪条件的描述符发送给进程。同时，使用FD_CLR宏函数将满足就绪条件的描述符从集合中移除。
(5).进入下一个循环，继续使用FD_SET宏函数向描述符集合中添加新的待监控描述符。然后重复(3)、(4)两个步骤。

如果使用简单的伪代码来描述：

```c
FD_ZERO
for() {
    FD_SET()
    select()
    if(){
        FD_ISSET()
        FD_CLR()
    }
    writen()
}
```

以上所说只是一种需要循环监控的示例，具体如何做却是不一定的。不过从中也能看出这一系列的流程。

### epoll

epoll 比 poll()、select() 先进，考虑以下几点，自然能看出它的优势所在：

(1).epoll_create() 创建的 epoll 实例可以随时通过 epoll_ctl() 来新增和删除感兴趣的文件描述符，不用再和 select() 每个循环后都要使用 FD_SET 更新描述符集合的数据结构。
(2).在 epoll_create() 创建 epoll 实例时，还创建了一个 epoll 就绪链表 list。而 epoll_ctl() 每次向 epoll 实例添加描述符时，还会注册该描述符的回调函数。当epoll 实例中的描述符满足就绪条件时将触发回调函数，被移入到就绪链表 list 中。
(3).当调用 epoll_wait() 进行监控时，它只需确定就绪链表中是否有数据即可，如果有，将复制到用户空间以被进程处理，如果没有，它将被阻塞。当然，如果监控的对象设置为非阻塞模式，它将不会被阻塞，而是不断地去检查。

也就是说，**epoll的处理方式中，根本就无需遍历描述符集合。**

相比 select 和 poll，**epoll 的高性能主要体现在3个方面**：==其一，每次在使用 poll 和 select 前，都需要重新准备一个待监控事件集合交给系统内核重新构建数据结构完成注册，而 epoll 是维护了一个全局事件集合，通过 epoll 句柄来管理；其二，每次在使用 poll 和 select 后，返回的都是就绪的事件个数，需要应用程序去遍历集合逐个判断，而 epoll 直接就将就绪事件集合返回，避免无效遍历；其三，poll 和 select 默认使用水平触发，当应用程序处理未完成时，需要内核不断通知应用，消耗性能，而 epoll 提供边缘触发，干脆只通知应用程序一次，你自己想办法处理，提高性能。==

