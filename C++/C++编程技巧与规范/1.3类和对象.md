# 类和对象

## 第三节 类的 public 继承（ is - a 关系）及代码编写规则

子类的继承方法有三种：public、protected、private。

public 代表的是一种 is - a 的关系，即通过这个子类生产的对象也一定是一个父类对象。

父类表现的是一种更泛化的概念，而子类表现的是一种更特化的概念。

public 继承关系的检验规则：能够在父类对象上做的行为也必然能在子类对象上做。

里氏替换原则：==任何基类出现的地方都可以无差别的使用子类替换==。

### 子类遮蔽父类的普通成员函数

对于 public 继承，不建议也不应该用子类内的普通成员函数遮蔽父类的同名普通成员函数。

既然在父类中是普通成员函数，那么就代表在子类中不会又不同的行为，代表的是一种不变形性。

### 父类的纯虚函数接口

纯虚函数： 让子类继承父类的成员函数接口。

纯虚函数意味着什么？

- 纯虚函数所在的类变成了抽象类，抽象类是不能用来生成该类对象的。
- 任何从抽象类继承的子类都要定义该虚函数自己的实现方法。

### 父类的虚函数接口

虚函数：让子类继承父类的成员函数接口和实现，子类还可以提供自己的新的实现。

### 为纯虚函数指定实现体

**纯虚函数也可以有实现体：**

```cpp
class A
{
public:
    virtual void eat() = 0; 			// 父类的纯虚函数
};

void A::eat()				// 父类纯虚函数的实现体
{
    std::cout << "吃饭了" << std::endl;
}

class B : public A
{
public:
    virtual void eat() override			// 子类重写父类纯虚函数，函数体内部调用父类纯虚函数
    {
        A::eat();
    }
};
```

给父类的纯虚函数增加实现体（函数体）目的有两个：

> 1. 强制子类必须实现该函数，以免产生一些重要的程序代码逻辑错误。
> 2. 让一些确实不需要单独实现父类纯虚函数的子类有机会直接调用父类的虚函数实现。

### 类的 public 继承（ is - a 关系）综合范例

```cpp
class A {};

class B : public A {};

class C : public B {};

void func(A tmpa)
{
    std::cout << "func(A)调用" << std::endl;
}

void func(C tmpa)
{
    std::cout << "func(C)调用" << std::endl;
}

int main()
{
    B b;
	C c;
	func(b);	// 输出 func(A)调用
    func(c);	// 输出 func(C)调用
}
```

上述代码中，B 类继承了 A 类， C 类继承了 B 类。那么 b 也属于 A 类，c 属于 B 类，也属于 A 类。

### public 继承关系下的代码编写规则

- 父类的普通成员函数，子类不应该去覆盖，如果需要覆盖，那么应该在父类中将该普通成员函数修改为虚函数。
- 父类的纯虚函数，定义了一个接口，子类等于继承了该接口，具体实现代码需要子类自己完成。
- 父类的普通虚函数（非纯虚函数），不但定义了一个接口，还书写了实现代码（缺省代码），子类继承了该接口，子类可以实现自己的代码来取代父类的代码，也可沿用父类的代码。
- 在可以使用非 public继承时，就不要使用 public 继承。