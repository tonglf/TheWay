# LeetCode 热题 HOT 100

## 1、两数之和

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

示例 1：

```cpp
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

示例 2：

```cpp
输入：nums = [3,2,4], target = 6
输出：[1,2]
```


示例 3：

```c++
输入：nums = [3,3], target = 6
输出：[0,1]
```

**题解：哈希表**

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> HashMap;
        for (int i = 0; i < nums.size(); ++i)
        {
            int n = target - nums[i];
            if (HashMap.find(n) != Map.end())
            {
                return {HashMap[n] ,i};
            }
            HashMap.insert(pair<int, int>(nums[i], i));
        }
        return {};
    }
};
```

- **时间复杂度：O(N)**

- **空间复杂度：O(N)**

## 2、两数相加

给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。

你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

示例1

```cpp
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[7,0,8]
解释：342 + 465 = 807.
```


示例 2：

```cpp
输入：l1 = [0], l2 = [0]
输出：[0]
```


示例 3：

```c++
输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
输出：[8,9,9,9,0,0,0,1]
```

**题解：**

```cpp
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2)
{
    ListNode *head = nullptr, *tail = nullptr;	// 需要初始化
    int carry = 0;
    while (l1 || l2)
    {
        int n1 = l1 ? l1->val : 0;
        int n2 = l2 ? l2->val : 0;        
        sum = n1 + n2 + carry;
        if (!head)
            head = tail = new ListNode(sum % 10);
        else
        {
            tail->next = new ListNode(sum % 10);
            tail = tail->next;
        }
        carry = sum / 10;
        if (l1)
            l1 = l1->next;
        if (l2)
            l2 = l2->next;
    }
    if (carry > 0)
        tail->next = new ListNode(carry);
    return head;
}
```

- **时间复杂度：O(N)**，N 为链表 l1 、 l2 的最大长度。

- **空间复杂度：O(1)**

## 3.无重复字符的最长子串

给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。

示例 1:

```cpp
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```


示例 2:

```cpp
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```


示例 3:

```c++
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```


示例 4:

```c++
输入: s = ""
输出: 0
```

**题解：滑动窗口**

```cpp
int lengthOfLongestSubstring(string s) 
{
    unordered_set<char> occ;			// 哈希集合，记录每个字符是否出现过
    int rk = -1, ans = 0;				// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
    for (int i = 0; i < s.size(); ++i)
    {
        if (i != 0)
            occ.erase(s[i - 1]);		// 左指针向右移动一格，移除一个字符
        while (rk + 1 < s.size() && !occ.count(s[rk + 1]))
        {
            occ.insert(s[rk + 1]);		// 不断地移动右指针
            rk++;
        }
        ans = max(ans, rk - i + 1);		// 第 i 到 rk 个字符是一个极长的无重复字符子串
    }
    return ans;
}
```

- **时间复杂度：O(N)**

- **空间复杂度：O(Σ)**，其中 Σ 表示字符集（即字符串中可以出现的字符）

## 4.寻找俩个正序数组的中位数

给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的中位数 。

示例 1：

```cpp
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```


示例 2：

```cpp
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
```


示例 3：

```cpp
输入：nums1 = [0,0], nums2 = [0,0]
输出：0.00000
```


示例 4：

```cpp
输入：nums1 = [], nums2 = [1]
输出：1.00000
```

**题解：二分法**

```cpp
double findMedianSortedArrays(int[] nums1, int[] nums2) 
{
	int length1 = nums1.size(), length2 = nums2.size();
	int totalLength = length1 + length2;
	if (totalLength % 2 == 1) 
    {
        int midIndex = totalLength / 2;
        double median = getKthElement(nums1, nums2, midIndex + 1);
        return median;
    } 
    else 
    {
        int midIndex1 = totalLength / 2 - 1, midIndex2 = totalLength / 2;
        double median = (getKthElement(nums1, nums2, midIndex1 + 1) 
                         + getKthElement(nums1, nums2, midIndex2 + 1)) / 2.0;
        return median;
    }
}

int getKthElement(int[] nums1, int[] nums2, int k) 
{
    int length1 = nums1.size(), length2 = nums2.size();
    int index1 = 0, index2 = 0;
    int kthElement = 0;
	while (true) 
    {
        // 边界情况
        if (index1 == length1) 
        {
            return nums2[index2 + k - 1];
        }
        if (index2 == length2) 
        {
            return nums1[index1 + k - 1];
        }
        if (k == 1) 
        {
            return Math.min(nums1[index1], nums2[index2]);
        }
            
        // 正常情况
        int half = k / 2;
        int newIndex1 = Math.min(index1 + half, length1) - 1;
        int newIndex2 = Math.min(index2 + half, length2) - 1;
        int pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2];
        if (pivot1 <= pivot2) 
        {
            k -= (newIndex1 - index1 + 1);
            index1 = newIndex1 + 1;
        } 
        else
        {    
         	k -= (newIndex2 - index2 + 1);
            index2 = newIndex2 + 1;
        }
    }
}
```

- **时间复杂度：O(log(m+n))**

- **空间复杂度：O(1)O(1)**

## 5.最长回文子串

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

示例 1：

```c++
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```


示例 2：

```cpp
输入：s = "cbbd"
输出："bb"
```


示例 3：

```c++
输入：s = "a"
输出："a"
```


示例 4：

```c++
输入：s = "ac"
输出："a"
```

**方法一：中心扩展法**

```cpp
string longestPalindrome(string s)
{
    int end = 0, start = 0;
    int left1, right1;
    int left2, right2;    
    for (int i = 0; i < s.size(); ++i)
    {
        auto [left1, right1] = extend(s, i, i, s.size());
        auto [left2, right2] = extend(s, i, i + 1, s.size());
        if (left1 - right1 > end - start)
        {
            start = left1;
            end = right1;
        }
        if (left2 - right2 > end - start)
        {
            start = left2;
            end = right2;
        }
    }
    return s.substr(start, (e))
}

pair<int, int> extend(const string s, int i, int j, int n)
{
    while (i >= 0 && j < n && s[i] == s[j])
    {
        i--;
        j++;
    }
    return {i + 1, j - 1};
}
```



**方法二：动态规划**

```cpp
```

## 10.正则表达式匹配

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
所谓匹配，是要涵盖整个字符串 s 的，而不是部分字符串。

示例 1：

```cpp
输入：s = "aa" p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
```


示例 2:

```cpp
输入：s = "aa" p = "a*"
输出：true
解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
```


示例 3：

```cpp
输入：s = "ab" p = ".*"
输出：true
解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
```

示例 4：

```c++
输入：s = "aab" p = "c*a*b"
输出：true
解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
```


示例 5：

```c++
输入：s = "mississippi" p = "mis*is*p*."
输出：false
```







## 11.盛最多水的容器

给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

说明：你不能倾斜容器。

示例 1：

![img](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

```cpp
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```


示例 2：

```cpp
输入：height = [1,1]
输出：1
```


示例 3：

```cpp
输入：height = [4,3,2,1,4]
输出：16
```


示例 4：

```cpp
输入：height = [1,2,1]
输出：2
```







## 15.三数之和

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

示例 1：

```cpp
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```


示例 2：

```cpp
输入：nums = []
输出：[]
```


示例 3：

```cpp
输入：nums = [0]
输出：[]
```







## 17.电话号码的字母组合

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/original_images/17_telephone_keypad.png" alt="img" style="zoom: 33%;" />

示例 1：

```cpp
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```


示例 2：

```c++
输入：digits = ""
输出：[]
```


示例 3：

```cpp
输入：digits = "2"
输出：["a","b","c"]
```





## 19.删除链表的倒数第 N 个结点

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**进阶：**你能尝试使用一趟扫描实现吗？

示例 1：

```cpp
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```


示例 2：

```c++
输入：head = [1], n = 1
输出：[]
```


示例 3：

```c++
输入：head = [1,2], n = 1
输出：[1]
```







## 20.有效的括号

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

有效字符串需满足：

左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。

示例 1：

```cpp
输入：s = "()"
输出：true
```


示例 2：

```cpp
输入：s = "()[]{}"
输出：true
```


示例 3：

```cpp
输入：s = "(]"
输出：false
```


示例 4：

```cpp
输入：s = "([)]"
输出：false
```


示例 5：

```cpp
输入：s = "{[]}"
输出：true
```







## 21.合并两个有序数组

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

示例 1：

![img](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)

```cpp
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```


示例 2：

```cpp
输入：l1 = [], l2 = []
输出：[]
```


示例 3：

```cpp
输入：l1 = [], l2 = [0]
输出：[0]
```







## 22.括号生成

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

示例 1：

```cpp
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

示例 2：

```c++
输入：n = 1
输出：["()"]
```





## 23.合并 K 个升序链表

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

 

示例 1：

```cpp
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```


示例 2：

```cpp
输入：lists = []
输出：[]
```


示例 3：

```cpp
输入：lists = [[]]
输出：[]
```







## 31.下一个排列

实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

必须 原地 修改，只允许使用额外常数空间。

示例 1：

```cpp
输入：nums = [1,2,3]
输出：[1,3,2]
```


示例 2：

```cpp
输入：nums = [3,2,1]
输出：[1,2,3]
```


示例 3：

```cpp
输入：nums = [1,1,5]
输出：[1,5,1]
```

示例 4：

```c#
输入：nums = [1]
输出：[1]
```





## 



## 33.搜索旋转排序数组

整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。

示例 1：

```cpp
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```


示例 2：

```cpp
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```


示例 3：

```cpp
输入：nums = [1], target = 0
输出：-1
```







## 34.在排序数组中查找元素的第一个和最后一个位置

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

进阶：

你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？

示例 1：

```cpp
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```


示例 2：

```cpp
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```


示例 3：

```cpp
输入：nums = [], target = 0
输出：[-1,-1]
```







## 39.组合求和

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

candidates 中的数字可以无限制重复被选取。

说明：

所有数字（包括 target）都是正整数。
解集不能包含重复的组合。 
示例 1：

```cpp
输入：candidates = [2,3,6,7], target = 7,
所求解集为：
[
  [7],
  [2,2,3]
]
```

示例 2：

```cpp
输入：candidates = [2,3,5], target = 8,
所求解集为：
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]
```







## 42.接雨水

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 

示例 1：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)

```c++
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```


示例 2：

```cpp
输入：height = [4,2,0,3,2,5]
输出：9
```







## 46.全排列

给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。

 示例 1：

```cpp
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

示例 2：

```cpp
输入：nums = [0,1]
输出：[[0,1],[1,0]]
```

示例 3：

```cpp
输入：nums = [1]
输出：[[1]]
```







## 48.旋转图像

给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。

示例 1：

![img](https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg)

```c++
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]
```


示例 2：

![img](https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg)

```cpp
输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
```

示例 3：

```cpp
输入：matrix = [[1]]
输出：[[1]]
```

示例 4：

```cpp
输入：matrix = [[1,2],[3,4]]
输出：[[3,1],[4,2]]
```







## 49.字母异位词分组

给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。

示例:

```cpp
输入: ["eat", "tea", "tan", "ate", "nat", "bat"]
输出:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]
```







## 53.最大子序和

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 

示例 1：

```cpp
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

示例 2：

```cpp
输入：nums = [1]
输出：1
```

示例 3：

```c++
输入：nums = [0]
输出：0
```

示例 4：

```cpp
输入：nums = [-1]
输出：-1
```

示例 5：

```cpp
输入：nums = [-100000]
输出：-100000
```







## 55.跳跃游戏

给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标。

示例 1：

```cpp
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
```


示例 2：

```cpp
输入：nums = [3,2,1,0,4]
输出：false
解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
```







## 56.合并区间

以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。 

示例 1：

```cpp
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

示例 2：

```cpp
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
```







## 62.不同路径

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

示例 1：

![img](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

```cpp
输入：m = 3, n = 7
输出：28
```


示例 2：

```cpp
输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。

1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
```

示例 3：

```cpp
输入：m = 7, n = 3
输出：28
```


示例 4：

```cpp
输入：m = 3, n = 3
输出：6
```







## 64.最小路径和

给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

示例 1：

![img](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)

```cpp
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```

示例 2：

```c++
输入：grid = [[1,2,3],[4,5,6]]
输出：12
```







## 70.爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

示例 1：

```cpp
输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。

1.  1 阶 + 1 阶
2.  2 阶
```

示例 2：

```cpp
输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。

1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶
```





## 75.颜色分类

给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。

示例 1：

```cpp
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```

示例 2：

```cpp
输入：nums = [2,0,1]
输出：[0,1,2]
```

示例 3：

````cpp
输入：nums = [0]
输出：[0]
````


示例 4：

```cpp
输入：nums = [1]
输出：[1]
```







## 76.最小覆盖子串

给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。

示例 1：

```c++
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
```


示例 2：

```cpp
输入：s = "a", t = "a"
输出："a"
```







## 78.子集

给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。

示例 1：

```cpp
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

示例 2：

```cpp
输入：nums = [0]
输出：[[],[0]]
```





## 79.单词搜索

给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

示例 1：

![img](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)

```cpp
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```


示例 2：

![img](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)

```cpp
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
输出：true
```


示例 3：

![img](https://assets.leetcode.com/uploads/2020/10/15/word3.jpg)

```cpp
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
输出：false
```







## 84.柱状图中最大的矩形

给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

 ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram.png)

以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。

 ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/histogram_area.png)

图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。

 

示例:

```cpp
输入: [2,1,5,6,2,3]
输出: 10
```







## 85.最大矩形

给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。

示例 1：

![img](https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg)

```c++
输入：matrix = [["1","0","1","0","0"],["1","0","1","1","1"],["1","1","1","1","1"],["1","0","0","1","0"]]
输出：6
解释：最大矩形如上图所示。
```

示例 2：

```c++
输入：matrix = []
输出：0
```

示例 3：

```cpp
输入：matrix = [["0"]]
输出：0
```

示例 4：

```c++
输入：matrix = [["1"]]
输出：1
```


示例 5：

```cpp
输入：matrix = [["0","0"]]
输出：0
```







## 94.二叉树的中序遍历

给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。



## 96.不同的二叉搜索树

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg)

```cpp
输入：n = 3
输出：5
```

**示例 2：**

```cpp
输入：n = 1
输出：1
```



## 98.验证二叉搜索树

给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：

节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。
示例 1:

```cpp
输入:
    2
   / \
  1   3
输出: true
```

示例 2:

```c++
输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5 ，但是其右子节点值为 4 。
```





## 101.对称二叉树

给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

    	1
       / \
      2   2
     / \ / \
    3  4 4  3

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

       1
      / \
      2   2
       \   \
       3    3
 



## 102.二叉树的层序遍历

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）。

 

## 104.二叉树的最大深度

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。



## 105.从前序与中序遍历序列构造二叉树

根据一棵树的前序遍历与中序遍历构造二叉树。



## 114.二叉树展开为链表

给你二叉树的根结点 root ，请你将它展开为一个单链表：

展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。
展开后的单链表应该与二叉树 先序遍历 顺序相同。

示例 1：

<img src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" alt="img" style="zoom:50%;" />

```cpp
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```


示例 2：

```cpp
输入：root = []
输出：[]
```


示例 3：

```cpp
输入：root = [0]
输出：[0]
```








## 121.买卖股票的最佳时机



## 124.二叉树中的最大路径和



## 128.最长连续序列



## 136.只出现一次的数字



## 139.单词拆分



## 141.环形链表



## 142.环形链表 II



## 146.LRU  缓存机制



## 148.排序链表



## 152.乘积最大数组



## 155.最小栈



## 160.相交链表



## 169.多元数组



## 198.打家劫舍



## 200.岛屿数量

[链接](https://leetcode-cn.com/problems/number-of-islands/)

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

示例 1：

```cpp
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

示例 2：

```cpp
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

**深度优先搜索**

我们可以将二维网格看成一个无向图，竖直或水平相邻的 11 之间有边相连。

为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 1，则以其为起始节点开始进行深度优先搜索。在深度优先搜索的过程中，每个搜索到的 1 都会被重新标记为 0。

最终岛屿的数量就是我们进行深度优先搜索的次数。

```cpp
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int count = 0;
        int r = grid.size();
        int c = grid[0].size();

        for (int i = 0; i < r; ++i)
        {
            for (int j = 0; j < c; ++j)
            {
                if (grid[i][j] == '1')
                {
                    count++;
                    dfs(grid, i, j);
                }
            }
        }
        return count;
    }

    void dfs(vector<vector<char>>& grid, int i, int j)
    {
        int r = grid.size();
        int c = grid[0].size();
        grid[i][j] = '0';

        if (i + 1 < r && grid[i + 1][j] == '1')     dfs(grid, i + 1, j);
        if (i - 1 >= 0 && grid[i - 1][j] == '1')    dfs(grid, i - 1, j);
        if (j + 1 < c && grid[i][j + 1] == '1')     dfs(grid, i, j + 1);
        if (j - 1 >= 0 && grid[i][j - 1] == '1')    dfs(grid, i, j - 1);
    }
};
```



## 206.反转链表



## 207.课程表



## 208.实现 Trie （前缀树）



## 215.数组中的第 K 个最大元素



## 221.最大正方形



## 226.翻转二叉树



## 234.回文链表



## 236.二叉树的最近公共祖先



## 238.除自身以外数组的乘积



## 239.滑动窗口最大值



## 240.搜索二维矩阵 II



## 253.会议室 II



## 279.完全平方数



## 283.移动零



## 287.寻找重复数



## 297.二叉树的序列化与反序列化



## 300.最长递增子序列



## 301.删除无效的括号



## 309.最佳买卖股票时机含冷冻期



## 312.戳气球



## 322.零钱兑换



## 337.打家劫舍 III



## 338.比特位计数



## 347.前 K 个高频元素



## 349.字符串解码



## 399.除法求职



## 406.根据身高重建队列



## 416.分割等和子集



## 437.路径总和 III



## 438.找到字符串中所有字母异或位词



## 448.找到所有数组中消失的数字



## 461.汉明距离



## 494.目标和



## 538.把二叉搜素树转换为累加树



## 543.二叉树的直径



## 560.和为 K 的子数组



## 581.最短无序连续子数组



## 617.合并二叉树



## 621.任务调度器



## 647.回文子串



## 739.每日温度
