# 十大排序算法

==默认从小到大排序，注释中**修改**的位置可以改变排序顺序。==

## 选择排序

**要点**：每次选择最小（最大）的数顺序放在前面的位置。

```cpp
void selectSort(vector<int>& nums)
{
    int index;									// 记录每次遍历最小值的索引
    for (int i = 0; i < nums.size(); ++i)
    {
        index = i;
        for (int j = i + 1; j < nums.size(); ++j)
        {
            if (nums[j] < nums[i])				// 修改：nums[j] > nums[i]
            {
                index = j;
            }
        }
        swap(nums[i], nums[index]);
    }
}
```

## 冒泡排序

**要点**：每次遍历比较两个相邻位置上的数是否符合排序要求。

```cpp
void bubbleSort(vector<int>& nums)
{
    bool swapped;										// 优化
    for (int i = 0; i < nums.size(); ++i)
    {
        swapped = false;
        for (int j = i; j < nums.size() - i - 1; ++j)
        {
            if (nums[j] > nums[j + 1]) 					// 修改：nums[j] < nums[j - 1]
            {
                swap(num[j], nums[j + 1]);
                swapped = true;
            }
        }
        if (!swapped)
            break;
    }
}
```

## 插入排序

**要点**：与插扑克牌一样，后来的元素插入到之前排好序元素的合适位置。

```cpp
void insertSort(vector<int>& nums)
{
    for (int i = 1; i < nums.size(); ++i)
    {
        for (int j = i; j > 0 && nums[j] < nums[j - 1]; --j)	// 修改：nums[j] > nums[j - 1]
        {
            swap(nums[j], nums[j - 1]);
        }
    }
}
```

## 快速排序

**要点**：在数组中选取一个数，令这个数作为基准，将比它小的数排在它前面，比它大的数排在它后面，形成的前后两个数组继续按照该方法排序。

```cpp
void quickSort(vector<int>& nums, int l, int r)				// 左闭右开的写法
{
    if (l + 1 >= r)
        return;
    int first = l, last = r - 1,  key = nums[first];
    while (first < last)
    {
        while (first < last && nums[last] >= key)		// 修改：nums[last] <= key
            --last;
        nums[first] = nums[last];
        while (first < last && nums[first] <= key)		// 修改：nums[first] >= key
            ++first;
        nums[last] = nums[first];
    }
    nums[first] = key;
    quickSort(nums, l , first);
    quickSort(nums, first + 1, r);
}
```

## 归并排序

**要点**：将一个数组拆分成两个数组，四个、八个······直到数组个数为1，再有序合并两两数组。

```cpp
void mergeSort(vector<int>& nums, int l, int r, vector<int>& temp)
{
	if (l + 1 >= r)
        return;
    int m = l + (r - l) / 2;
    mergeSort(nums, l, m, temp);
    mergeSort(nums, m, r, temp);
    int p = l, q = m, i = l;
    while (p < m || q < r)
    {
        if (q >= r || (p < m && nums[p] <= nums[q]))	// 修改：nums[p] >= nums[q]
            temp[i++] = nums[p++];
        else
            temp[i++] = nums[q++];
    }
    for (i = l; i < r; ++i)
        nums[i] = temp[i];
}
```

## 希尔排序

**要点**：分间隔对数组排序，间隔以 2 倍速，由大到小，知道间隔为 1。

```cpp
void shellSort(vector<int>& nums)
{
    for (int gap = nums.size(); gap > 0; gap /= 2)
    {
        for (int i = gap; i < nums.size(); ++i)
        {													// 修改：num[j] < num[j + gap]
            for (int j = i - gap; j >= 0 && num[j] > num[j + gap]; j -= gap)
            {
                swap(nums[j], nums[j + gap]);
            }
        }
    }
}
```

## 堆排序

**要点**：

```cpp
```

## 计数排序

**要点**：利用元素下表来确定元素的正确位置。

```cpp
void countSort(vector<int>& nums, vector<int>& output) 
{
	// 1.得到数列的最大值和最小值，并算出差值d
	int max = nums[0];
	int min = nums[0];
	for (int i = 1; i < nums.size(); ++i) 
    {
		if(nums[i] > max) 
			max = nums[i];
		if(nums[i] < min) 
			min = nums[i];
	}
    
	int d = max - min;
	// 2.创建统计数组并统计对应元素个数
	vector<int> temp(d + 1);
	for (int i = 0; i < nums.size(); ++i)
    {
        temp[nums[i] - min]++; 
    }	
    
    for (int i = 1; i < temp.size(); ++i)
    {
        temp[i] = temp[i - 1];
    }
    
    for (int i = nums.size() - 1; i >= 0; --i)
    {
        output[temp[nums[i] - min] - 1] = nums[i];
        output[array[i] - min]--;
    }
   
}
```

**说明**：

## 桶排序

**要点**：

```cpp
```

**说明**：

## 基数排序

**要点**：

```cpp
```

