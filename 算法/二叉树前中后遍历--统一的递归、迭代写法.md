# 二叉树前中后遍历--统一的递归、迭代写法

**二叉树定义：**

```cpp
struct TreeNode {
	int val;
	TreeNode *left;
	TreeNode *right;
	TreeNode() : val(0), left(nullptr), right(nullptr) {}
	TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
	TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
```

递归法：

```cpp
void preorderTraversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return; 
    vec.push_back(cur->val);    		// 中
    preorderTraversal(cur->left, vec);  // 左
    preorderTraversal(cur->right, vec); // 右
}

void inorderTraversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    inorderTraversal(cur->left, vec);  // 左
    vec.push_back(cur->val);    	   // 中
    inorderTraversal(cur->right, vec); // 右
}

void postorderTraversal(TreeNode* cur, vector<int>& vec) {
    if (cur == NULL) return;
    postorderTraversal(cur->left, vec);  // 左
    postorderTraversal(cur->right, vec); // 右
    vec.push_back(cur->val);    		 // 中
}
```



迭代法：==三种遍历方式都是借助栈的方法，总体上差别不大。==

**中序遍历：**

```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> s;
        TreeNode* cur = root;
        while (!s.empty() || cur != nullptr)
        {
            if (cur != nullptr)
            {
                s.push(cur);
                cur = cur->left;					// 进入最左侧节点
            }
            else
            {
                cur = s.top();
                result.push_back(cur->val);			// 输出节点值
                s.pop();
                cur = cur->right;					// 转移至右节点
            }
        }
        return result;
    }
};
```



**前序遍历：**

```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> s;
        TreeNode* cur = root;
        while (!s.empty() || cur)
        {
            if (cur)
            {
                result.push_back(cur->val);			// 输出节点值
                s.push(cur);
                cur = cur->left;					// 进入最左侧节点
            }
            else
            {
                cur = s.top();
                s.pop();
                cur = cur->right;					// 转移至右节点
            }
        }    
        return result;
    }
};
```



**后续遍历：**

```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        vector<int> result;
        stack<TreeNode*> s;
        TreeNode* cur = root;
        while (!s.empty() || cur)
        {
            if (cur)
            {
                result.push_back(cur->val);			// 输出节点值
                s.push(cur);
                cur = cur->right;					// 进入最右侧节点
            }
            else
            {
                cur = s.top();
                s.pop();
                cur = cur->left;					// 转移至右节点
            }
        }
        reverse(result.begin(), result.end());    	// 翻转一下数组
        return result;	
    }
};
```

**总结：**

- 前序遍历与中序遍历只是在输出节点的位置不同，其余都一样。

- 前序遍历与后续遍历在左右子树进栈顺序不同，前序先左后右，后序先右后做，最后后序需要翻转一下数组。

