# 2021 秋招面经总结 —— C++ 篇（一）

> 作者：leetcode-Crystal

当然只看总结好的面经并不一定能够完全理解其中的知识点，建议看到不懂的地方查阅下《C++Primer》这本书。这本书内容十分全面，但是也比较厚，可以作为一本工具书来看，如果从头到尾看下来可能比较耗时间，推荐的做法是抽取其中的一部分知识点来看，边看边总结。笔者当时是从头到尾看了一遍，极为不推荐这种方式，因为重难点内容往往静不下心来看。

## （0）C++ 程序的编译过程（源码如何转化成二进制）

参考链接： 🔗 https://blog.csdn.net/u012662731/article/details/78520349

编译过程分为四个过程：**预处理**、**编译**，**汇编**，**链接**

- 编译预处理：处理以 # 开头的指令
- 编译、优化：将源码 .cpp 文件翻译成 .s 汇编代码
- 汇编：将汇编代码 .s 翻译成机器指令 .o 文件
- 链接：汇编程序生成的目标文件并不会立即执行，可能有源文件中的函数引用了另一个源文件中定义的符号或者调用了某个库文件中的函数。那链接的目的就是将这些目标文件连接成一个整体，从而生成可执行的二进制文件。

![1.编译过程](.\Image\1.编译过程.png)

**链接分为两种**：（静态库、动态库）

参考链接： 🔗 https://www.cnblogs.com/cyyljw/p/10949660.html

- 静态链接：代码从其所在的动态链接库中拷贝到最终的可执行程序中，在该程序被执行时，这些代码会被装入到该进程的虚拟地址空间中

- 动态链接：代码被放到动态链接库或共享对象的某个目标文件中，链接程序只是在最终的可执行程序中记录了共享对象的名字等一些信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进行的虚拟地址的空间

**二者的优缺点：**

- 静态链接：浪费空间，每个可执行程序都会有目标文件的一个副本，这样如果目标文件进行了更新操作，就需要重新进行编译链接生成可执行程序（更新困难）；优点就是执行的时候运行速度快，因为可执行程序具备了程序运行的所有内容

- 动态链接：节省内存、更新方便，但是动态链接是在程序运行时，每次执行都需要进行链接，性能会有一定的损失。

## （1）指针和引用的区别

- 指针所指向的内存空间在程序运行过程中可以改变，而引用所绑定的对象一旦绑定就不能改变。（**是否可变**）
- 指针本身在内存中占有内存空间，引用相当于变量的别名，在内存中不占内存空间（**是否占内存**）
- 指针可以为空，但是引用必须绑定对象（**是否可为空**）
- 指针可以有多级，但是引用只能一级（**是否能为多级**）

## （2）堆和栈的区别

- **申请方式**：栈是系统自动分配，堆是程序员主动申请
- **申请后系统响应**：分配栈空间，如果剩余空间大于申请空间则分配成功，否则分配失败栈溢出；申请堆空间，堆在内存中呈现的方式类似于链表（记录空闲地址空间的链表），在链表上寻找第一个大于申请空间的节点分配给程序，将该节点从链表中删除，大多数系统中该块空间的首地址存放的是本次分配空间的大小，便于释放，将该块空间上的剩余空间再次连接在空闲链表上

- 栈在内存中是**连续**的一块空间（向低地址扩展）最大容量是系统预定好的，堆在内存中的空间（向高地址扩展）是**不连续**的

- **申请效率**：栈是有系统自动分配，申请效率高，但程序员无法控制；堆是由程序员主动申请，效率低，使用起来方便但是容易产生碎片
- **存放的内容**：栈中存放的是局部变量，函数的参数；堆中存放的内容由程序员控制

## （3）new 和 delete 是如何实现的，new 与 malloc 的异同处

在使用的时候 new，delete 搭配使用，malloc 和 free 搭配使用。·

- **属性**：malloc/free 是库函数，需要**头文件**的支持；new/delete 是关键字，需要**编译器**的支持

- **参数**：new 申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；malloc 在申请空间时，需要确定所申请空间的大小

- **返回值**：new 申请空间时，返回的类型是对象的指针类型，无需强制类型转换，符合类型安全的操作符；malloc 申请空间时，返回的是 void* 类型，需要进行强制类型的转换，转换为对象类型的指针

- **分配失败**：new 分配失败时，会抛出 bad_alloc 异常，malloc 分配失败时返回**空指针**

- **重载**：new/delete 支持重载，malloc/free 不能进行重载

- **自定义类型实现**：new 首先调用 operator new 函数申请空间（底层通过 malloc 实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；delete 首先调用析构函数，然后调用 operator delete 释放空间（底层通过 free 实现）。**malloc/free 无法进行自定义类型的对象的构造和析构**

- **内存区域**：new 操作符从**自由存储区**上为对象动态分配内存，而 malloc 函数从**堆**上动态分配内存。（自由存储区不等于堆）

## （4）C 和 C++ 的区别

- C 是面向过程的编程，特点是函数；

- C++ 是面向对象的编程，特点是类。（**特性**）

- ==C 主要用在**嵌入式开发**、**驱动开发**和**硬件**直接打交道的领域；C++ 可以用于**应用层的开发**、**用户界面开发**等和**操作系统**直接打交道的领域==。（**应用领域**）

- C++ 继承了 C 的底层操作特性，增加了**面向对象的机制**，增加了**泛型编程**、**异常处理**、**运算符重载**，还增加了**命名空间**，避免了命名冲突。（**相较于 C 的升级**）

## （5）C++、Java 的联系与区别，包括语言特性、垃圾回收、应用场景等（Java 的垃圾回收机制）

**二者在语言特性上有很大的区别：**

- **指针**：C++ 可以直接操作指针，容易产生内存泄漏以及非法指针引用的问题；Java 并不是没有指针，虚拟机(JVM)内部还是使用了指针，只是编程人员不能直接使用指针，不能通过指针来直接访问内存，并且 Java 增加了内存管理机制

- **多重继承**：C++ 支持多重继承，允许多个父类派生一个类，虽然功能很强大，但是如果使用的不当会造成很多问题，例如：菱形继承；Java 不支持多重继承，但允许一个类可以继承多个接口，可以实现 C++ 多重继承的功能，但又避免了多重继承带来的许多不便

- **数据类型和类**：C++ 可以将变量或函数定义成全局，但是 Java 是完全面向对象的语言，除了基本的数据类型之外，其他的都作为类的对象，包括数组。

**垃圾回收：**

- Java 语言一个显著的特点就是**垃圾回收机制**，编程人员无需考虑内存管理的问题，可以有效的防止内存泄漏，有效的使用空闲的内存

- Java 所有的对象都是用 new 操作符建立在内存堆栈上，类似于 C++ 中的 new 操作符，但是当要释放该申请的内存空间时，Java 自动进行内存回收操作，C++ 需要程序员自己释放内存空间，**并且 Java 中的内存回收是以线程的方式在后台运行的，利用空闲时间。**

**应用场景：**

- Java 运行在虚拟机上，和开发平台无关，C++ 直接编译成可执行文件，是否跨平台在于用到的编译器的特性是否有多平台的支持，

- C++ 可以直接编译成可执行文件，运行效率比 Java 高

- Java 主要用来开发 web 应用

- C++ 主要用在嵌入式开发、网络、并发编程的方面

## （6）struct 和 class 的区别

参考链接：https://blog.csdn.net/bestconvenient/article/details/30734139

struct 和 class 都可以自定义数据类型，也支持继承操作

- struct 中默认的访问级别是 public，默认的继承级别也是 public
- class 中默认的访问级别是 private，默认的继承级别也是 private
- 当 class 继承 struct 或者 struct 继承 class 时，默认的继承级别取决于 class 或 struct 本身， class (private 继承) ，struct (public 继承)

```cpp
struct A{}；

class B : A {};   // private继承

struct C : B {}； // public继承
```

- class 可以使用**模板**，struct 不能

## （7）define 和 const 的区别（编译阶段、安全性、内存占用等）

- **编译阶段**：**define 是在编译预处理阶段起作用，const 是在编译阶段和程序运行阶段起作用**

- **安全性**：define 定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全的检查；const 定义的只读变量是有类型的，是要进行判断的，可以避免一些低级的错误

- **内存占用**：define 定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份；const 定义的只读变量在程序运行过程中只有一份

- **调试**：define 定义的不能调试，因为在预编译阶段就已经进行替换了；const 定义的可以进行调试

**const** **的优点：**

- 有数据类型，在定义式可进行安全性检查
- 可调式
- 占用较少的空间

## （8）在 C++ 中 const 和 static 的用法（定义，用途）

 🔗 [const 参考](https://blog.csdn.net/Eric_Jo/article/details/4138548?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param)

- const 修饰成员变量，定义成 const 常量，相较于宏常量，可进行类型检查，节省内存空间，提高了效率

- const 修饰函数参数，使得传递过来的函数参数的值不能改变

- ==const 修饰成员函数，使得成员函数不能修改任何类型的成员变量（ mutable 修饰的变量除外，函数参数也除外），也不能调用非 const 成员函数，因为非 const 成员函数可能会修改成员变量==

**static** **定义静态变量，静态函数**

- static 作用于**局部变量**，改变了局部变量的生存周期，使得该变量存在于定义后直到程序运行结束的这段时间

- static 作用于**全局变量和函数**，改变了全局变量的作用域，使得全局变量只能在定义它的文件中使用，在源文件中不具有全局可见性

- static 作用于**类的成员变量和类的成员函数**，使得类变量或者类成员函数和类有关，也就是说可以不定义类的对象就可以通过类访问这些静态成员。注意：类的静态成员函数中只能访问静态成员变量或者静态成员函数，**不能将静态成员函数定义成虚函数**

## （9）const 和 static 在类中使用的注意事项（定义、初始化和使用） 

 🔗 [参考](https://www.runoob.com/w3cnote/cpp-static-const.html)

**static** **静态成员变量：**

​	1、静态成员变量是在类内进行声明，在类外进行定义和初始化，在类外进行定义和初始化的时候不要出现 static 关键字和 private/public/protected 访问规则。

```cpp
class A
{
	static int a;
};

int a = 5;
```

​	2、静态成员变量相当于类域中的全局变量，被类的所有对象所共享，包括派生类的对象。

​	3、**静态成员变量可以作为成员函数的参数可选参数**，而普通成员变量不可以

```cpp
class base{ 
public : 
  static int _staticVar; 
  int _var; 
    
  void foo1(int i = _staticVar);    // 正确, _staticVar 为静态数据成员 
  void foo2(int i = _var);        // 错误, _var 为普通数据成员 
};
```

​	4、静态数据成员的类型可以是所属类的类型，而普通数据成员不可以，普通数据成员只可能声明成类的指针或引用

```cpp
class base{ 
public : 

  static base _object1;    	// 正确，静态数据成员 

  base _object2;         	// 错误 (造成循环创建 base 类，导致栈溢出)

  base *pObject;         	// 正确，指针 

  base &mObject;       		// 正确，引用 

};
```

**static** **静态成员函数：**

- 静态成员函数不能调用非静态成员变量或者非静态成员函数，因为静态成员函数没有 this 指针。静态成员函数做为类作用域的全局函数

- **静态成员函数不能声明成虚函数（virtual）、const、volatile**

**const** **成员变量：**

- **const 成员变量只能在类内声明、定义，在构造函数初始化列表中初始化**

```cpp
class A
{
public:
	int get()
	{
		return a;
	}

private:
	const int a = 6;			// 可以直接初始化
};
```

```cpp
class B
{
public:
	B(int b) : m_ib(b) {}		// 初始化 const 成员变量
	void get()
	{
		std::cout << m_ib << std::endl;
	}

private:
	const int m_ib;				// 若不初始化，必须在构造函数初始化列表中初始化
};
```

- **const 成员变量只在某个对象的生存周期内是常量，对于整个类而言却是可变的**，因为类可以创建多个对象，不同类的 const 成员变量的值是不同的，所以不能在类的声明中初始化 const 成员变量，因为类的对象还没有创建，编译器不知道它的值

**const** **成员函数：**

- 不能修改成员变量的值，除非有 mutable 修饰；只能访问成员变量

- 不能调用非常量成员函数，以防修改成员变量的值

**const static**：

- 如果要想成员变量在整个类中都是恒定的常量，应该用类的枚举常量或者 static const.

- 在类中进行声明，在类外进行初始化（类似于类的静态常量）

## （10）C++ 中的 const 类成员函数（用法和意义）

用法：如上

意义：防止修改成员变量

 

**本篇重点总结：**

- 编译过程
- new delete , free malloc 区别和联系
- C++ 和 C 的区别
- C++ 和 Java 的区别
- struct class 区别
- define const 区别
- const static 用法和作用

 

# 2021 秋招面经总结 —— C++ 篇（二）

本篇是即 上一篇面经之后的第二篇面经，涉及 C++ 在面试过程中常问道的知识点，也是笔者在面试过程中曾经被问到的题目，但是由于公司的不同，面试官的不同，问道的问题的深度也不一样，建议在复习基础知识的时候，首先拓展自己的宽度，当宽度足够了再加深自己的深度。举个非常简单的例子：面试官可能会问道多态是怎么实现的，开始复习的时候可能仅能回答上来“多态是通过虚函数来实现的”；那么更为理想的答案是在回答的过程中我们也简单把 “虚函数的底层实现方式” 简单描述下，这就体现出我们回答的问题是有深度的。

## （11）计算下面几个类的大小：

🔗 [参考链接](https://blog.csdn.net/fengxinlinux/article/details/72836199)

类本身没有大小，这里类的大小是指：类对象所占的大小。

- 类的大小遵循结构体的对齐规则

- 类的大小与普通成员函数和静态成员无关（包括：普通成员函数、静态成员函数、静态数据成员、静态常量数据成员），与普通数据成员有关

- 虚函数对类的大小有影响，是因为虚函数指针的影响

- 虚继承对类的大小有影响，是因为虚基表指针带来的影响

- 空类的大小是 1

例子：

```cpp
class A{       
    static int a;    		//静态成员 
    const static int b;      
    static int fun1() {}        
    void fun() {}  			//普通成员函数  
};
  
class B{    
    int a;     //普通数据成员 
};

class C{    
    virtual int fun() {}  	// 虚函数 
};

//结构体对齐原则  
class D{    
    int a;         
    virtual int fun(){}         
};

int main()
{
  cout << sizeof(A) << endl;	// 1

  cout << sizeof(B) << endl;	// 4:表示一个整型变量的大小

  cout << sizeof(C) << endl;	// 8：虚函数表的指针的大小

  cout << sizeof(D) << endl;	// 16：整型变量的大小 + 虚函数指针的大小 + 对齐原则（4）

  return 0;
}
```

## （12）给一个代码，求输出结果

```cpp
class A 
{
public:
    A(int x) { }
};
```

问：A a = 1;是否正确, 如果正确, 那么它调用了哪些函数？

正确，这里会进行隐式转化 A a(1).implicit

这类题目更常见的是在基类和子类有不同实现方法。（虚函数相关，例子很多，不多说了）

## （13）C++ 的 STL 介绍

（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理 allocator，函数，实现机理，多线程实现等，笔者也整理过 STL 相关的面经，有兴趣的可以自行查阅

## （14）STL 源码中的 hash 表的实现

hashtable 是采用开链法来完成的，（vector + list）

- 底层键值序列采用 **vector** 实现，vector 的大小取的是质数，且相邻质数的大小约为 2 倍关系，当创建 hashtable 时，会自动选取一个接近所创建大小的质数作为当前 hashtable 的大小；

- 对应键的值序列采用**单向 list** 实现；

- 当 hashtable 的键 vector 的大小重新分配的时候，原键的值 list 也会重新分配，因为 vector 重建了相当于键增加了，那么原来的值对应的键可能就不同于原来分配的键，这样就需要重新确定值的键。

## （15）STL 中 unordered_map 和 map 的区别

- 底层实现不同：

unordered_map 底层实现是一个**哈希表**，元素**无序**

map 底层实现是**红黑树**，其内部所有的元素都是**有序**的，因此对 map 的所有操作，其实都是对红黑树的操作

- 优缺点：

unordered_map：查找效率高；但是建立哈希表比较耗费时间

map：内部元素有序，查找和删除操作都是 log(n) 的时间复杂度；但是维护红黑树的存储结构需要占用一定的内存空间

- 适用情况：

对于要求内部元素有序的使用 map，对于要求查找效率的用 unordered_map

## （16）STL 中 vector 的实现

- vector 是一个动态数组，底层实现是一段连续的线性内存空间。

- 扩容的本质：当vector实际所占用的内存空间和容量相等时，如果再往其中添加元素需要进行扩容。其步骤如下：

  ​	首先，申请一块更大的存储空间，一般是增加当前容量的 50% 或者 100%，和编译器有关；

  ​	然后，将旧内存空间的内容，按照原来的顺序放到新的空间中

  ​	最后，将旧内存空间的内容释放掉，本质上其存储空间不会释放，只是删除了里面的内容。

- 从 vector 扩容的原理也可以看出：vector 容器释放后，与其相关的指针、引用以及迭代器会失效的原因。

## （17）vector 使用的注意点及其原因，频繁对 vector 调用 push_back() 对性能的影响和原因

主要是在插入元素方面：插入元素需要考虑元素的移动问题和是否需要扩容的问题

频繁的调用 push_back() 也是扩容的问题对性能的影响

## （18）C++ 中的重载和重写（覆盖）的区别：

- 对于类中函数的重载或者重写而言，重载发生在同一个类的内部，重写发生在不同的类之间，子类和父类之间

- 重载的函数需要与原函数有相同的函数名、不同的参数列表，不关注函数的返回值类型；重写的函数的函数名、参数列表和返回值类型都需要和原函数相同，父类中被重写的函数需要有 virtual 修饰

- virtual 关键字：重写的函数基类中必须有 virtual 关键字的修饰，重载的函数可以有 virtual 关键字的修饰也可以没有

## （19）C++ 内存管理（热门问题，问过）

🔗 [参考](https://blog.csdn.net/caogenwangbaoqiang/article/details/79788368)

**C++ 内存分区**：**栈**、**堆**、**自由存储区**、**全局/静态存储区**、**常量区**

栈：存放函数的局部变量，由编译器自动分配和释放

堆：动态申请的内存空间，就是由 malloc 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没有释放，操作系统会自动回收

自由存储区：和堆十分相似，存放由 new 分配的内存块，由 delete 释放内存

全局区/静态区：存放全局变量和静态变量

常量存储区：存放的是常量，不允许修改

**堆和自由存储区的区别：**

🔗 [参考链接](https://www.cnblogs.com/qg-whz/p/5060894.html)

- 自由存储是 C++ 中通过 new 与 delete 动态分配和释放对象的抽象概念，而堆是 C 语言和操作系统的术语，是操作系统维护的一块动态分配内存

- new 所申请的内存区域在 C++ 中成为自由存储区。即由堆实现的自由存储，可以说 new 所申请的内存区域在堆上

- 堆和自由存储区有区别，并非等价。使用 new 来分配内存，程序员也可以通过重载操作符，改用其他内存来实现自由存储，例如全局变量做的对象池，这时自由存储区就区别于堆了。

**指针和数组的对比：**

1、字符数组的内容可以改变，字符指针的内容不可以改变

```cpp
char a[] = "hello";

a[0] = 'l';          // 正确

char *p = "world";   // p 指向常量字符串

p[0] = 'h';          // 运行出错
```

2、字符数组之间不能赋值，不能直接用比较运算符直接比较，若进行赋值调用 strcpy() 函数，若进行比较调用 strcmp() 函数；

```cpp
char a[] = "hello";

char b[10];

strcpy(b, a);           //不能用 b = a;

if(strcmp(a, b) == 0)     //不能用 a == b
    cout << "endl";
```

3、运算符 sizeof 可以计算出字符数组的容量，但是计算字符指针时，得到的是指针变量所占用的空间，而不是指针所指向空间的大小。

```cpp
char a[] = "hello";

char *p = a;

cout << sizeof(a) << endl;     // 6 字节

cout << sizeof(p) << endl;    // 8 字节（ 64 位）

// 但是当数组作为参数传递时，数组会自动退化为指针

void fun(char a[100])
{
    cout << sizeof(a) << endl;	// 结果是 8（ 64 位）
}
```

**调用函数申请空间**

​	1、**指针作为函数的参数传递**：

```cpp
void GetMemory(char *p, int num) 
{
	p = (char *)malloc(sizeof(char) * num);
}

void Test(void) 
{
	char *str = NULL;
	GetMemory(str, 100); 	// str 仍然为 NULL
	strcpy(str, "hello"); 	// 运行错误
}
```

上述程序出错的原因在于：调用函数时，传递的是变量的值 “值传递”，在 GetMemory 函数内部改变的是参数 p 的副本，并不会影响参数 p 本身，也就是说 str 并没有获得内存。这样程序最终会导致内存泄漏，调用 GetMemory 函数多少次，就会出现多少次内存泄漏，因为在函数内部只动态申请了内存，并没有用 free 释放掉动态内存空间。

如果想要通过这种方式申请空间，将 GetMemory 函数的形参改为 “**指向指针的指针**”

```cpp
void GetMemory2(char **p, int num) 
{
	*p = (char *)malloc(sizeof(char) * num);
}

void Test2(void) 
{
	char *str = NULL;
	GetMemory2(&str, 100); 	// 注意参数是 &str，而不是 str
	strcpy(str, "hello");
	free(str);				// 特别注意：这里是将动态申请的内存空间释放掉
}
```

​	2、**用函数的返回值来传递动态申请的内存空间**

```cpp
char *GetString(void) 
{
	char p[] = "hello world";
	return p; 					// 编译器将提出警告：将局部变量返回
}

char *GetString2(void) 
{
	char *p = "hello world";
	return p;					// 编译器给出警告：将 string const 转化成 char*
}

void Test4(void) 
{
	char *str = NULL;
	str = GetString(); 			// str 的内容是垃圾
	cout<< str << endl;
}

void  Test5(void) 
{  　
    char *str = NULL;  　
    str = GetString2();  　
    cout<< str << endl;  
}
```

**在一个函数中如何返回一个变量的指针？**

对于普通变量而言，是存储在栈内存中，当函数调用完毕后，栈内存的空间会被释放，如果返回局部变量的指针，回到主调函数后，该指针是悬挂指针指向垃圾内存，如何来处理这种情况呢？

可以返回存储在堆内存或者全局区的变量的指针：

- 返回静态类型对象的指针，会导致占用大量的内存空间

- 返回存放在堆上的对象的指针，该对象所在的内存空间由用户控制什么时候释放，那如何知道什么时候释放合适呢？可以用只智能指针来处理，智能指针内部有计数器，当计数器为 0 时，会自动释放该内存。

```cpp
int func1(int  param) 
{   
    int local_param = param;   
    return local_param;  
}

// 返回静态变量的地址   
int* func2(int param) 
{   
    static int local_param = param;  
    return &local_param; 
}

// 返回存放在堆上变量的地址*   
int* func3(int param) 
{   
    int *new_param = new int(param);   
    return new_param; 
}

int main() 
{
	int *pNewVar = func3(3);
	int *pVar = func2(2);

	cout << *pVar << endl;		// 2
	cout << *pNewVar << endl;	// 3
	cout << func1(1) << endl;

	return 0;
}
```

**出现野指针的情形：**

​	1、指针定义的时候未初始化

​	2、指针指向动态分配的内存空间在释放（delete 或 free）后，未置为 NULL，让人误以为是合法指针

​	3、指针操作超过了变量的作用范围。例如：在函数中将一个局部变量的地址作为函数的返回值，这里编译器会给出警告，因为离开该函数后，局部变量的空间就会释放掉，返回的地址（指针）相当于是野指针。

**深拷贝和浅拷贝带来的问题：**

类中默认的拷贝构造函数和赋值构造函数都是浅拷贝，当类的成员变量中出现指针变量时，最好使用深拷贝，避免内存空间多次释放的问题出现。

**内存泄漏：**

内存泄漏常指的是堆内存泄漏，当然还包括系统资源的泄漏

🔗 [参考链接](https://blog.csdn.net/bl520025/article/details/8967648)

**野指针：** 指针指向的内存空间已经释放掉

**悬挂指针：** 指针指向的内存空间由于中间改变了其指向，之前的内存空间已无法释放，个人认为是和内存泄漏相似。

感觉二者并没有什么区别！！！！

野指针和悬挂指针都是指向垃圾内存的

 

本篇中知识点小结：

- 类大小的计算

- STL 相关知识点：hash表的实现原理，vector 的实现原理，vector 使用注意的地方，unordered_map 和 map 的区别

- 重载和重写的区别

- 内存管理：内存分区，堆和自由存储区的区别，指针和数组的比较，内存泄漏深拷贝和浅拷贝，悬挂指针和野指针

 

# 2021 秋招面经总结 —— C++ 篇（三）

## （20）面向对象和面向过程的区别（问过）

- **面向过程：** 以事件为中心的编程思想，编程时把解决问题的**步骤**分析出来，然后用**函数**把这些步骤实现，在一步一步的具体步骤中再按顺序调用函数

- **面向对象**： 世界上有很多的人和事物，每一个都可以看作一个对象，每个对象都有自己的**属性**和**行为**，对象和对象之间可以通过方法来交互，对象的抽象称为类

## （21） 什么是面向对象，介绍面向对象的三大特性，并且举例说明每一个。

面向对象：对象是指具体的某一个事物，这些事物的抽象就是类，类中包含数据（成员变量）和动作（成员方法）。

- 封装：将具体的实现过程和数据封装成一个函数，只能通过接口进行访问，降低耦合性。

- 继承：子类继承父类的特征和行为，子类有父类的非 private 方法或成员变量，子类可以对父类的方法进行重写，增强了类之间的耦合性，但是当父类中的成员变量、成员函数或者类本身被 final 关键字修饰时，修饰的类不能继承，修饰的成员不能重写或修改。

- 多态：多态就是不同继承类的对象，对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现方式

## （22） 多态的实现和应用场景

多态通过虚函数实现

应用场景：在实际开发中，**一个功能有多种实现方式**，流程相同，但是具体的细节有区别，例如：支付功能，可以进行支付宝支付、微信支付等

## （23） C++ 虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）

虚函数是通过虚函数表来实现的，虚函数表里面保存了虚函数的地址，这张表保存在含有虚函数的类的实例对象的内存空间中，虚函数表的指针存放在对象实例的最前面的位置

虚函数表是在编译阶段建立的，也就是说在程序的编译过程中会将虚函数的地址放在虚函数表中。（问过）

## （24）虚继承（和虚函数混合在一起问）

**提出：**

虚继承是为了解决**多重继承**中**命名冲突**和**数据冗余**问题而提出的。例如：类 D 继承类 B1, B2，而类 B1, B2 都继承自类 A，因此在类 D 中出现两次类 A 中的变量和函数，那为了节省内存空间可以将 B1, B2 对 A 的继承定义为虚继承，而 A 就成了虚基类。

 <img src=".\Image\2.虚继承.png"/>

```cpp
class A {};

class B1 : public virtual A {};

class B2 : public virtual A {};

class D : public B1, public B2 {};
```

这样使用虚继承就能够确保在派生类 D 中只保存一份 A 的成员变量和成员函数。

虚继承的目的是让某个类做出声明，承诺愿意共享它的基类，这个被共享的基类就称为虚基类。

**虚基类的成员可见性问题：**

假设 A 中定义了一个名为 x 的成员变量，当我们直接访问 x 时，会有三种可能：

- 如果 B1, B2 中都没有定义 x，那么 x 将被解析为 A 的成员，不存在二义性；

- 如果 B1 或 B2 其中的一个类定义了 x，那么也不存在二义性的问题，派生类的 x 比虚基类的 x 的优先级更高；

- 如果 B1 和 B2 中都定义了 x，那么直接访问 x 会产生二义性问题

## （25） 实现编译器处理虚函数表应该如何处理

- 编译器将虚函数表的指针放在类的实例对象的内存空间中，该对象调用该类的虚函数时，通过指针找到虚函数表，根据虚函数表中存放的虚函数的地址找到对应的虚函数。

- 如果派生类没有重新定义基类的虚函数 A，则派生类的虚函数表中保存的是基类的虚函数 A 的地址，也就是说基类和派生类的虚函数 A 的地址是一样的

- 如果派生类重写了基类的某个虚函数 B，则派生的虚函数表中保存的是重写后的虚函数 B 的地址，也就是说虚函数 B 有两个版本，分别存放在基类和派生类的虚函数表中

- 如果派生类重新定义了新的虚函数 C，派生类的虚函数表保存新的虚函数 C 的地址

## （26） 析构函数一般写成虚函数的原因

析构函数定义成虚函数是为了**防止内存泄漏**，因为当父类的指针或者引用指向或绑定到子类的对象时，如果未将基类的析构函数定义成虚函数，会调用基类的析构函数，那么只能将基类的成员所占的空间释放掉，派生类中特有的就会无法释放内存空间导致内存泄漏。

## （27） 构造函数为什么一般不定义为虚函数

- 从**存储空间**的角度考虑，构造函数是在实例化对象的时候进行调用，如果此时将构造函数定义成虚函数，需要通过访问该对象所在的内存空间才能进行虚函数的调用（因为需要通过指向虚函数表的指针调用虚函数表，虽然虚函数表在编译时就有了，但是没有虚函数的指针，虚函数的指针只有在创建了对象才有），但是此时该对象还未创建，便无法进行虚函数的调用。所以构造函数不能定义成虚函数。

- 从使用的角度来看，虚函数是基类的指针指向派生类的对象时，通过该指针实现对派生类的虚函数的调用，构造函数是在创建对象时自动调用的

- 从实现上来看，虚函数表是在创建对象之后才有的，因此不能定义成虚函数

- 从类型上来看，在创建对象时需要明确其类型

 

本篇涉及的知识点大多是和面向对象中的类相关的，笔者认为这也是C++中的重点。当然面经对问题的答案描述的比较精简，想更深刻的掌握知识点的精髓建议翻翻书看看，毕竟书中的语言更加严谨。

 

# 2021 秋招面经总结 —— C++ 篇（四）

## （28） 构造函数或者析构函数中调用虚函数会怎样

[参考](https://blog.csdn.net/henrytien/article/details/80064863)

- 程序可以正常运行

- 但是无法达到虚函数调用的效果，当用基类的指针指向派生类的对象时，在调用基类的构造函数时，若出现虚函数的调用，程序的本意是调用派生类中的虚函数，但是当虚函数出现在构造函数或者析构函数中时，调用的是其所在类（基类）的虚函数。**派生类对象构造期间进入基类的构造函数时，对象的类型变成了基类类型，而不是派生类类型。同样进入基类析构函数时，对象也是基类类型。**

## （29） 纯虚函数

- 纯虚函数在类中声明时，加上 = 0，

- 含有纯虚函数的类称为抽象基类（只要含有纯虚函数这个类就是抽象类），类中只有接口，没有具体的实现方法

- 继承纯虚函数的派生类，如果没有完全实现基类纯虚函数，依然是抽象类，不能实例化对象。

- 抽象类对象不能作为函数的参数，不能创建对象，不能作为函数返回类型；

- 抽象类可以声明为抽象类指针，可以声明抽象类的引用；

- 子类必须继承父类的纯虚函数，并全部实现后，才能创建子类的对象。

## （30） 静态绑定和动态绑定的介绍

**静态类型和动态类型：**

- 静态类型：变量在声明时的类型，是在**编译期**确定的。静态类型不能更改

- 动态类型：目前所指对象的类型，是在**运行期**确定的。动态类型可以更改

**静态绑定和动态绑定：**

- 静态绑定是指程序在**编译的过程中**确定对象的类型（静态类型）

- 动态绑定是指程序在**运行期间**确定对象的类型（动态类型）

**静态绑定和动态绑定的区别：**

- 发生的时期不同：如上

- 对象的静态**类型**不能更改，动态类型可以更改

- 要想实现**多态**，必须进行动态绑定

- 在继承体系中，只有**虚函数**是动态绑定，其他都是静态绑定

**编译时多态和运行时多态（面试时问过）：**

- 编译时多态：在程序编译过程中出现，发生在**模板**和**函数重载**中（泛型编程）

- 运行时多态：在程序运行过程中出现，发生在**继承**体系中，是指通过基类的指针或引用访问派生类中的虚函数

**编译时多态和运行时多态的区别：**

- 编译时多态发生在程序编译过程中，运用泛型编程来实现，在编译时完成，提升程序的运行效率，但是对于无法实现模板的分离编译对于大程序编译时十分耗时

- 编译时多态无法处理异质对象的集合（异质对象是通过异质类定义的，异质类是指存储类型不一致的数据对象）

- 运行时多态体现了面向对象的特征，但是虚函数会占用一定的存储空间

- 运行时多态发生在程序的运行过程中，编译器无法进行优化处理

引申出：**显示接口和隐式接口**

- 显示接口：能够明确来源的接口，例如在运行时多态中，能够明确的知道所调用的函数是来源于哪个类

- 隐式接口：无法确定来源的接口，例如对于函数重载和模板，不知道是调用哪个实现

## （31） 引用是否能实现动态绑定，为什么引用可以实现

[参考链接](https://www.cnblogs.com/fandingBlog/p/3918407.html)

能够实现动态绑定，因为对象的类型是确定的，引用时在运行阶段根据他们绑定的具体对象的类型确定的。

最根本的原因在于：多态是通过虚函数实现的，而虚函数是通过存储在对象的内存空间中的指针调用的；

- 当基类的指针指向派生类的对象时，向上进行类型转化的是地址，此时**派生类的对象中指向虚函数的指针并不会发生变化**，只是改变了基类指针的地址，因此可以实现多态

- 当派生类的对象赋值给基类的对象，此时派生类对象的指向虚函数的指针会发生变化（隐式的向上转化），变为基类的对象的虚函数的指针，因此无法实现多态

## （32） 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）

[参考](https://blog.csdn.net/liitdar/article/details/81904009)

如果一个类拥有资源，该类的对象发生了复制，如果资源发生了重新分配，就是深拷贝，否则就是浅拷贝

- 深拷贝：该对象和原对象占用不同的存储空间，即拷贝位于 stack 域（栈）中的内容，又拷贝类中位于 heap 域（堆）中的内容

- 浅拷贝：该对象和原对象占用同一块内存区域，仅拷贝类中位于 stack 域（栈）中的内容

当类的成员变量中有指针时，使用深拷贝安全，如果两个对象指向同一块内存空间，当其中一个对象的删除后，该块内存空间就会被释放，另外一个对象指向的就是垃圾内存。

## （33） 对象复用的了解，零拷贝的了解(没问到过)

- 零拷贝：不需要 cpu 参与在内存之间复制数据的操作

- 对象的复用：享元模式，通过创建一个对象池，以避免对象的重复创建

## （34） 介绍C++所有的构造函数

构造函数的作用：当创建对象时，系统分配了内存空间后，会自动调用相应的构造函数

- 默认构造函数：没有参数，如果创建了一个类，没有定义任何构造函数，系统会自动生成默认的构造函数

- 一般构造函数：带有参数，一个类可以有若干个一般构造函数，前提是参数的数量或者类型不同（C++ 重载函数原理）

- 拷贝构造函数：参数为该类的常量引用对象，如果类中没有定义拷贝构造函数，系统会默认生成一个默认的拷贝构造函数，默认生成的拷贝构造函数都是浅拷贝的

- 赋值构造函数：区别于以上构造函数，以上构造函数都没有函数的返回类型，这里虽然称为 “赋值构造函数”，其实是 “重载了赋值运算符的函数”，该函数的返回类型是该类的引用类型，参数是该类的常量引用对象。

**拷贝构造函数（复制）和赋值构造函数（赋值）的区别：**

[参考链接](https://blog.csdn.net/liitdar/article/details/81904009)

- 二者的参数类型都是该类的常量引用对象，但是，拷贝构造函数没有返回类型，赋值构造函数的返回类型是该类的引用类型

- 在实现过程中，调用拷贝构造函数是在创建一个新的对象时，所以在函数内直接申请空间 (heap) 然后给相应的成员变量赋值即可；调用赋值构造函数时，源对象和目标对象都已声明，所以在函数内需要将目标对象的内存空间（heap）释放掉，重新申请空间，再进行拷贝操作

- 二者的使用场景不同，拷贝构造函数的使用场景见如下三种情况

## （35） 什么情况下会调用拷贝构造函数（三种情况）

[参考](https://blog.csdn.net/liitdar/article/details/81877373)

- 创建类的对象时，有两种情形：**代入法** classA obj(1,2)；**赋值法** classB obj1 = obj

- 当类的对象作为**函数的参数**时，由实参到形参的复制过程会调用拷贝构造函数
- 当类的对象作为**函数的返回值**时，会将返回值通过调用拷贝构造函数复制给一个临时对象，并传到函数的调用处

 

不得不说，C++ 的知识点还是蛮多的，但是功夫不负有心人，耐心复习，总会把面试中的高频知识点吃透。但提醒大家一点，刚开始复习的时候，注重知识的广度，不能说我只会虚函数，无论问我虚函数相关的什么知识点我都能答上来，包括虚函数的实现原理，虚函数表等等，但是问我智能指针就一问三不知了。随着复习的遍数增加，每复习以一遍，建议增加复习的深度，可能第一遍仅停留在概念层面，那么第二面就要关注下原理，第三遍呢就要看下源代码。

 

# 2021 秋招面经总结 —— C++ 篇（五）

## （36） 结构体内存对齐方式和为什么要进行内存对齐？（问到过）

[参考链接](https://blog.csdn.net/sweetfather/article/details/78487563)

结构体的大小并不是各数据成员之和，而是按照一定的对齐数进行对齐存储，最后结构体的大小也是按照一定的对齐数进行对齐。

**对齐规则：**

- 第一个成员在与结构体变量偏移量为 0 的地址

- 其他成员变量要对齐到对齐数字的整数倍地址处
- 对齐数 = 编译器默认的对齐数（vs:8, linux:4）与该成员大小较小的值
- 结构体总的大小为默认对齐数的整数倍

注意一点：当内存中的变量变换了顺序后，那么该结构体对象或者该类的对象所占的内存空间也会发生变化。

 ```cpp
 class MyStruct {
 
   char dda;  // 偏移量为 0，满足对齐方式，dda 占用 1 个字节；
 
   double dda1; // 下一个可用的地址的偏移量为 1，不是 sizeof(double) = 8 的倍数，需要补足 7 个字节才能使偏移量变为8（满足对齐方式），因此 VC 自动填充 7 个字节，dda1 存放在偏移量为 8 的地址上，它占用 8 个字节。
 
   int type;  // 下一个可用的地址的偏移量为 16，是 sizeof(int) = 4的倍数，满足 int 的对齐方式，所以不需要 VC 自动填充，type 存放在偏移量为 16 的地址上，它占用4个字节。
     
 }; 	// 共占 20 个字节，不是默认偏移量（8）的整数倍，需要进行字节填充，最终占 24 个字节
 
  
 class MyStruct1{
 
   double d1;	// 偏移量 0，满足对齐方式，d1 占用 8 个字节
 
   char d2;		// 偏移量为 8，满足对其方式（是 1 的倍数），占用 1 个字节
 
   int d3;		// 偏移量为 9，不满足对其方式（不是 4 的倍数），需要补 3 个字节，9 + 3 + 4 = 16
 
 };				// 最终，占 16 个字节，是默认偏移量（8）的整数倍，不用补充字节
 
 int main() 
 {
   cout << sizeof(MyStruct) << endl;			// 24
 
   cout << sizeof(MyStruct1) << endl;		// 16
 
   return 0;
 }
 ```

**进行内存对齐的原因：**

- 平台的移植性好，并不是所有的硬件平台都能存放任意地址的数据，某些平台只能在某些地址访问特定类型的数据，否则就会出现异常

- cpu 处理效率高：cpu 并不是把内存看成以字节为单位，而是以块为单位，cpu 在读取内存的时候是一块一块的读取的

## （37） 内存泄露的定义，如何检测与避免？

**内存泄漏：**由于疏忽或错误导致程序未能释放掉不再使用的内存，并不是说这块内存在物理上消失，而是说失去了对这块内存的**控制**，因而造成了内存的浪费

**检测**内存泄漏的方法：

- 使用工具软件BoundChecker

- 运行 DEBUG 版程序，运用以下技术：CRT(C Run-time libraries)、运行时函数调用堆栈、内存泄漏时提示的内存分配序号，综合分析内存泄漏的原因

**解决**内存泄漏的方法：**智能指针**

## （38） 智能指针

智能指针是为了解决动态内存分配时带来的内存泄漏以及多次释放同一块内存空间而提出的。

- 共享指针（shared_ptr）：资源可以被多个指针共享，使用计数机制表明资源被几个指针共享。通过 use_count() 查看资源的所有者的个数，当该变量的值变为 0 后，会自动释放内存空间，从而避免了内存泄漏。

- 独占指针（unique_ptr）：资源只能被一个指针占有，该指针不能拷贝构造和赋值

- 弱指针（weak_ptr）：指向 share_ptr 指向的对象，能够解决由 shared_ptr 带来的循环引用问题

**weak_ptr 如何解决 shared_ptr 的循环引用问题？（问过）**

循环引用：该被调用的析构函数没有被调用，从而出现了内存泄漏

- weak_ptr 对被 shared_ptr 管理的对象存在非拥有性（弱）引用，在访问所引用的对象前必须先转化为 shared_ptr

- weak_ptr 用来打断 shared_ptr 所管理对象的循环引用问题，若这种环被孤立（没有指向环中的外部共享指针），shared_ptr 引用计数无法抵达 0，内存被泄露； 能令环中的指针之一为弱指针可以避免该情况

- weak_ptr 用来表达临时所有权的概念，当某个对象只有存在时才需要被访问，而且随时可能被他人删除，可以用 weak_ptr 跟踪该对象；需要获得所有权时将其转化为 shared_ptr，此时如果原来的 shared_ptr 被销毁，则该对象的生命期被延长至这个临时的shared_ptr 同样被销毁

**智能指针的实现：**

 ```cpp
 #include <iostream>
 #include <memory>
 
 template <typename T>
 class SmartPtr 
 {
 private : 
     T *_ptr;
     size_t *_count;
 
 public:
 	SmartPtr(T *ptr = nullptr) : _ptr(ptr) 
 	{
 		if (_ptr) 
     	{
         	_count = new size_t(1);
 		} 
 		else 
 		{
 	    	_count = new size_t(0);
     	}
 	}
 
 	~SmartPtr() 
     {
         (*this->_count)--;
         if (*this->_count == 0) 
         {
             delete this->_ptr;
             delete this->_count;
         }
     }
 
 	SmartPtr(const SmartPtr &ptr)  // 拷贝构造
     {        
         if (this != &ptr) 
         {
             this->_ptr = ptr._ptr;
             this->_count = ptr._count;
             (*this->_count)++;
         }
     }
 
 	SmartPtr &operator=(const SmartPtr &ptr) 	// 赋值运算符重载
 	{  
         if (this->_ptr == ptr._ptr) 
         {
             return *this;
         }
 		if (this->_ptr) 
         {
             (*this->_count)--;
             if (this->_count == 0) 
             {
                 delete this->_ptr;
                 delete this->_count;
             }
         }
 		this->_ptr = ptr._ptr;
         this->_count = ptr._count;
         (*this->_count)++;
         return *this;
 	}
 
 	T &operator*() 
     {
 		assert(this->_ptr == nullptr);
         return *(this->_ptr);
     }
 
 	T *operator->() 
     {
         assert(this->_ptr == nullptr);
         return this->_ptr;
     }
 
 	size_t use_count() 
     {
         return *this->count;
     }
 };
 ```

## （39） 调试程序的方法，（程序异常退出如何排查，问到过）

- IDE 设置断点进行调试

- Linux 中没有 IDE，可以打印 log

- 打印中间结果

- 生成 core 文件

## （40） 遇到 coredump 要怎么调试（问过）

[参考链接](https://blog.csdn.net/zhu2695/article/details/51512138)

- 打开生成 core 文件的开关 ulimit -c unlimited

- 输入 gdb core 文件名 core

- 输入 where 命令，可以找到错误的根源

## （41） 内存检查工具的了解

[参考链接](https://blog.csdn.net/gatieme/article/details/51959654)

## （42） 模板的用法与适用场景

在 C++ 11 中模板新加了一些的特性，模板分为类模板和函数模板

- 函数模板：在定义一个函数时，可以用指定的关键字来代替其类型，template\<typename T> + 函数头（ 例如：void cmp(const T &a, const T& b) ）

- 类模板：和函数模板类似，在定义一个类时，将成员变量的类型用一个指定的关键字来代替，template\<class T> + 类定义（ class A { } ）

使用场景： [参考链接](https://www.cnblogs.com/liguangsunls/p/7247006.html)

- 数据类型和算法相分离的**泛型编程**

## （43） 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？

[参考链接](https://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html)

成员初始化列表用来完成类中成员函数的初始化操作，初始化的顺序和在类中声明的顺序有关。

- 对于**内置类型**而言，在构造函数中使用初始化列表和在构造函数体中进行赋值，性能没什么差别

- 但是对于**自定义类型**而言，==**使用初始化列表可以使变量在初始化的时候直接调用拷贝构造函数即可；如果是在函数体中进行赋值，会先调用默认的构造函数创建该对象，然后调用赋值构造函数进行赋值**==。

## （44） 用过 C++ 11吗，知道 C++ 11 新特性吗？（有面试官建议熟悉C++ 11）

- 智能指针

- lambda表达式

- 模板、泛型编程

## （45） C++ 的调用惯例（简单一点 C++ 函数调用的压栈过程）

将参数压栈，然后压入函数返回地址，进行函数调用，通过跳转指令进入函数，将函数内部的变量去堆或栈上开辟空间，执行函数功能，执行完成，取回函数返回地址，进行接下来的执行过程

## （46） C++的四种强制转换

[参考链接](https://www.cnblogs.com/Allen-rg/p/6999360.html)

- static_cast：用于**数据**的强制类型转换，强制将一种数据类型转换为另一种数据类型
  1. 用于基本数据类型的转换
  2. 用于类层次之间的基类和派生类之间指针或者引用的转换（不要求必须包含虚函数，但必须是有相互联系的类），进行上行转换（派生类的指针或引用转换成基类表示）是安全的；进行下行转换（基类的指针或引用转换成派生类表示）由于没有动态类型检查，所以是不安全的，最好用 dynamic_cast 进行下行转换。
  3. 可以将空指针转化成目标类型的空指针
  4. 可以将任何类型的表达式转化成 void 类型

- const_cast：强制**去掉常量属性**，不能用于去掉变量的常量性，只能用于去除指针或引用的常量性，将常量指针转化为非常量指针或者将常量引用转化为非常量引用（注意：表达式的类型和要转化的类型是相同的）

```cpp
int main() 
{
	const int a = 10;
    const int * p = &a;
    
    int *q;
    q = const_cast<int *>(p);
    *q = 20;  // fine，去掉指针的常量属性去改变指针所指向的常量的值，虽然指向的是同一内存空间，但是常量的值不会发生变化

    cout << a << " " << *p << " " << *q << endl; 	// 输出：10 20 20
    cout << &a << " " << p << " " << q << endl;		// 输出：0x23fe2c 0x23fe2c 0x23fe2c

	return 0;
}
```

- reinterpret_cast：改变指针或引用的类型、将指针或引用转换为一个足够长度的整型、将整型转化为指针或引用类型

- dynamic_cast：
  1. 其他三种都是编译时完成的，动态类型转换是在程序运行时处理的，运行时会进行类型检查
  2. **只能用于带有虚函数的基类或派生类的指针或者引用对象的转换**，转换成功返回指向类型的指针或引用，转换失败返回 NULL；不能用于基本数据类型的转换
  3. 在向上进行转换时，即子类的指针转换成父类的指针和 static_cast 效果是一样的，（注意：这里只是改变了指针的类型，指针指向的对象的类型并未发生改变）

 ```cpp
 class A {
 public:
     virtual void f() 
     {
         cout<<"hello"<<endl;
     }
 };
 
 class B : public A
 {
 public:
   void f() 
   {
       cout<<"hello2"<<endl;
   }
 };
 
 int main() 
 {
 
 	A* a1 = new B;	// a1 是 A 类型的指针指向一个 B 类型的对象
 
 	A* a2 = new A;	// a2 是 A 类型的指针指向一个 A 类型的对象
 
 	B* b = new B;
 
     // 向上类型转换,只是改变了 b 指针的类型，其所指对象的类型并未发生改变,依然是指向 B 类型的对象
 	a2 = dynamic_cast<A*>(b);
 
 	if (a2 == NULL) 
     {
 		cout << "null" << endl;
     } 
     else 
     {
 		cout << "not null" << endl;		// 输出
 	}
 
 	a2->f(); // 输出 hello2,因为 b 自身指向的对象的类型就是 B 类型
 
 	b->f();	// 输出hello2
 
 	// 向下转换：指针所指向的对象类型和要转换成的指针类型不相同-->转换失败
 
 	b = dynamic_cast<B*>(a2);	// 此时 a2 指向的对象的类型已经发生了改变，正好和 b 指向的对象类型相同（成功）
 
 	if (b == NULL) 
     {
         cout << "null" << endl;
     } 
     else 
     {
         cout << "not null" << endl; // 输出
     }
 
 	return 0;
 }
 
 // 输出结果：
 // not null
 // hello2
 // hello2
 // not null
 ```

​		4. 在下行转换时，父类的指针类型转化为子类的指针类型，只有当要转换的指针指向的对象类型和转化以后的对象类型相同时，才会转化成功

```cpp
class A {
public:
    virtual void f() 
    {
        cout << "hello" << endl;
    }
};

class B : public A {
public:
    void f() 
    {
        cout << "hello2" << endl;
    }
};

int main()
{
	A* a1 = new B;	// a1 是 A 类型的指针指向一个 B 类型的对象

	A* a2 = new A;// a2是A类型的指针指向一个A类型的对象

	B* b;

	// 向下转换：指针所指向的对象类型和要转换成的指针类型相同-->转换成功
	b = dynamic_cast<B*>(a1); // 结果为 not null，向下转换成功，a1 之前指向的就是 B 类型的对象，所以可以转换成 B 类型的指针  

	if ( b == NULL ) 
    {
        cout<<"null"<<endl;
    } 
    else 
    {
        cout<<"not null"<<endl;
    }
    
    a1->f();

	// 向下转换：指针所指向的对象类型和要转换成的指针类型不相同-->转换失败

	b = dynamic_cast<B*>(a2); // 结果为 null，向下转换失败

	if ( b == NULL ) 
    {
        cout<<"null"<<endl;
    } 
    else 
    {
        cout<<"not null"<<endl;
    }

	return 0;
}

// 输出结果：
// not null
// hello2
// null
```

# 2021 秋招面经总结 —— C++ 篇（六）

## （47）函数指针和指针函数

[参考链接](https://blog.csdn.net/qq_31672701/article/details/108566678)

- 函数**指针**（指向函数的指针）：本质上是一个指针，只不过这个指针指向了一个函数，保存的是这个函数的地址（函数名）。

```c++
int (*p)(int, int)	// 表示所指向的函数返回值是 int 型，参数是两个 int 型
```

- 指针**函数**（**函数的返回值是指针**）：本质上是一个函数，只不过返回值是指针类型。 

```cpp
int* fun(int x, int y) { }	// 这个 fun 函数的返回值是指针类型
```

## （48）构造函数的调用次数

注意：有一个类 A，

- 如果定义该类型的一个数组 `A t[5]; `数组长度是几，就会调用几次构造函数

- 如果定义该类型的指针数组` A *p[5];`不会调用构造函数，这里数组中存放的是指向 A 类型的对象的指针

## （49）析构函数和构造函数的调用顺序

```cpp
#include <iostream>
using namespace std;

// 之前定义了class A、class B、class C、class D

C c;

int main()
{
    A *pa = new A();
    B b;
    static D d;
    delete pa;  
    return 0;
}

// 运行结果：
// C construct;
// A construct;
// B construct;
// D construct;
// A destruct;
// B destruct;
// D destruct;
// C destruct;
```

解释：

- A先析构的原因在于调用了 delete A，

- 当离开函数的作用域时，也就是执行到 main 函数的右括号时，会释放存放在栈内存的空间，会将局部变量 b 析构掉

- 当程序执行完毕时，会释放存放在全局区的变量，先释放 d，因为 d 是后构造的；再释放 c。（变量 c 是全局变量，在调用 main 函数之前进行构造）

## （50）auto 和 decltype 的区别

auto 和 decltype 都用于类型推导：

- 语法格式不同：

```cpp
auto var = value; // auto 根据 = 右面的初始值 value 推导出变量 var 的类型；

decltype(表达式) var2 [= value]; // decltype 根据后面括号中的表达式推导出变量的类型，和 =右面的 value 没有关系；
```

- auto 要求变量必须初始化，即定义变量的时候必须赋值；decltype 将变量的类型和初始值分开

## （51）哪些运算符不能重载

[参考链接](http://c.biancheng.net/cpp/biancheng/view/2188.html)

C++ 中绝大部分运算符都能重载。

不能重载的运算符（只有5个）：

- `. 成员访问运算符` ，保证访问成员的功能不能被改变

- `.* 成员指针访问运算符`，保证访问成员的功能不能被改变

- `:: 域运算符`，运算对象是类型而不是变量

- `sizeof 长度运算符`，运算对象是类型而不是变量或一般表达式，不具备重载特征

- `?: 条件运算符`，运算对象是类型而不是变量或一般表达式，不具备重载特征

## （52） 运算符重载函数声明为一般函数还是友元函数，以及运算符重载的一些注意事项

[参考链接](https://blog.csdn.net/KingCat666/article/details/44870799)

- 运算符重载可以重载为类的成员函数，也可以是类的友元函数。

- 一般情况下，**单目运算符重载为类的成员函数，双目运算符重载为类的友元函数**

**注意事项：**

- 有五种不能重载的运算符："." , ".*", "::", "sizeof", "?:"

- 重载的运算符必须限制在可重载的运算符之中，不能创造新的运算符

- 遵循函数重载的原则，但是不能有默认的参数

- 重载后的运算符不能改变运算符的优先级和结合性，也不能改变运算符操作数的个数及语法结构，不能改变内部对象的含义

- 自定义类型的运算符一般都先重载后使用，但是 "=" 和 “&” 可以不用重载

## （53）静态函数能否定义成虚函数

[参考链接](https://www.cnblogs.com/lakeone/p/5967548.html)

**静态成员函数不能被声明为虚函数：**

- **静态成员不属于任何类对象或类实例，所以即使加上 virtual 也没有任何意义**

- ==静态与非静态成员函数之间一个最主要的区别就是：**静态成员函数没有 this 指针**==。调用类中的虚函数时，是通过虚表以及指向虚表的指针 vptr 才能完成虚函数的调用，并且只能用 this 指针来访问。对于静态成员函数没有 this 指针，无法访问 vptr.

**静态成员函数不能为 const 函数：**

当声明一个类（Test）的非静态成员函数为 const 时，this 指针相当于 `Test const *`，对于非 const 成员函数，this 指针相当于 `Test *`。 **但是 static 成员函数没有 this 指针，所以用 const 来修饰 static 没有任何意义**。（volatile 的道理也是如此）

 

面经 C++ 篇就到此结束了，当然不可避免的有些知识点未涉及到，建议大家在复习的过程中，以此作为参考，并不断地将其中没有涉及的知识点收纳在自己的知识库中，多复习多巩固，向更深入的方向努力。面试过程中，永远想象不到面试官会挖的多深！

